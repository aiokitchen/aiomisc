# Translations template for aiomisc.
# Copyright (C) 2021
# This file is distributed under the same license as the aiomisc project.
# Dmitry Orlov <me@mosquito.su>, 2022.
msgid ""
msgstr ""
"Project-Id-Version:  14\n"
"Report-Msgid-Bugs-To: me@mosquito.su\n"
"POT-Creation-Date: 2026-02-09 00:43+0100\n"
"PO-Revision-Date: 2026-02-09 12:00+0100\n"
"Last-Translator: Dmitry Orlov <me@mosquito.su>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/threads.rst:2
msgid "Working with threads"
msgstr "Работа с потоками"

#: ../../source/threads.rst:5
msgid "Why use threads with asyncio?"
msgstr "Зачем использовать потоки с asyncio?"

#: ../../source/threads.rst:7
msgid ""
"Asyncio is designed for non-blocking I/O operations, but many libraries "
"and operations are inherently blocking:"
msgstr ""
"Asyncio предназначен для неблокирующих операций ввода-вывода, но многие "
"библиотеки и операции по своей природе блокирующие:"

#: ../../source/threads.rst:10
msgid "File I/O (reading/writing files)"
msgstr "Файловый ввод-вывод (чтение/запись файлов)"

#: ../../source/threads.rst:11
msgid "CPU-intensive computations"
msgstr "Ресурсоёмкие вычисления"

#: ../../source/threads.rst:12
msgid "Legacy libraries without async support"
msgstr "Старые библиотеки без поддержки async"

#: ../../source/threads.rst:13
msgid "Database drivers without async support"
msgstr "Драйверы баз данных без поддержки async"

#: ../../source/threads.rst:14
msgid "System calls that don't have async alternatives"
msgstr "Системные вызовы без асинхронных альтернатив"

#: ../../source/threads.rst:16
msgid ""
"Running blocking code directly in an async function blocks the entire "
"event loop, preventing other coroutines from executing. The solution is "
"to run blocking code in separate threads while the event loop continues "
"processing other tasks."
msgstr ""
"Выполнение блокирующего кода напрямую в async-функции блокирует весь "
"event loop, не давая выполняться другим сопрограммам. Решение — "
"запускать блокирующий код в отдельных потоках, пока event loop "
"продолжает обрабатывать другие задачи."

#: ../../source/threads.rst:21
msgid ""
"aiomisc provides convenient decorators and utilities to seamlessly "
"integrate blocking code with asyncio, powered by the `aiothreads`_ "
"library."
msgstr ""
"aiomisc предоставляет удобные декораторы и утилиты для бесшовной "
"интеграции блокирующего кода с asyncio на базе библиотеки `aiothreads`_."

#: ../../source/threads.rst:27
msgid "Quick reference"
msgstr "Краткий справочник"

#: ../../source/threads.rst:30
msgid "Decorator/Class"
msgstr "Декоратор/Класс"

#: ../../source/threads.rst:30
msgid "Use case"
msgstr "Применение"

#: ../../source/threads.rst:32
msgid "``@threaded``"
msgstr ""

#: ../../source/threads.rst:32
msgid "Run blocking function in thread pool"
msgstr "Запуск блокирующей функции в пуле потоков"

#: ../../source/threads.rst:34
msgid "``@threaded_separate``"
msgstr ""

#: ../../source/threads.rst:34
msgid "Run blocking function in new thread"
msgstr "Запуск блокирующей функции в новом потоке"

#: ../../source/threads.rst:36
msgid "``@threaded_iterable``"
msgstr ""

#: ../../source/threads.rst:36
msgid "Async iterate over blocking generator"
msgstr "Асинхронная итерация по блокирующему генератору"

#: ../../source/threads.rst:38
msgid "``@threaded_iterable_separate``"
msgstr ""

#: ../../source/threads.rst:38
msgid "Same, but on separate thread"
msgstr "То же, но в отдельном потоке"

#: ../../source/threads.rst:40
msgid "``IteratorWrapper``"
msgstr ""

#: ../../source/threads.rst:40
msgid "Wrap existing generator for async iteration"
msgstr "Обёртка существующего генератора для асинхронной итерации"

#: ../../source/threads.rst:42
msgid "``sync_await``"
msgstr ""

#: ../../source/threads.rst:42
msgid "Call async function from thread"
msgstr "Вызов async-функции из потока"

#: ../../source/threads.rst:44
msgid "``FromThreadChannel``"
msgstr ""

#: ../../source/threads.rst:44
msgid "Send data from thread to async code"
msgstr "Отправка данных из потока в async-код"

#: ../../source/threads.rst:49
msgid "``@aiomisc.threaded``"
msgstr ""

#: ../../source/threads.rst:51
msgid ""
"Wraps a blocking function to run it in the current thread pool. The "
"decorated function becomes awaitable."
msgstr ""
"Оборачивает блокирующую функцию для выполнения в текущем пуле потоков. "
"Декорированная функция становится awaitable."

#: ../../source/threads.rst:55
msgid "Basic usage"
msgstr "Базовое использование"

#: ../../source/threads.rst:57
msgid ""
"import asyncio\n"
"import time\n"
"from aiomisc import threaded\n"
"\n"
"\n"
"@threaded\n"
"def blocking_function():\n"
"    time.sleep(1)\n"
"    return \"done\"\n"
"\n"
"\n"
"async def main():\n"
"    # Run two blocking calls in parallel\n"
"    results = await asyncio.gather(\n"
"        blocking_function(),\n"
"        blocking_function(),\n"
"    )\n"
"    print(results)  # ['done', 'done']\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import time\n"
"from aiomisc import threaded\n"
"\n"
"\n"
"@threaded\n"
"def blocking_function():\n"
"    time.sleep(1)\n"
"    return \"done\"\n"
"\n"
"\n"
"async def main():\n"
"    # Запуск двух блокирующих вызовов параллельно\n"
"    results = await asyncio.gather(\n"
"        blocking_function(),\n"
"        blocking_function(),\n"
"    )\n"
"    print(results)  # ['done', 'done']\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../source/threads.rst:83
msgid "Calling modes"
msgstr "Способы вызова"

#: ../../source/threads.rst:85
msgid ""
"The ``@threaded`` decorator returns a ``Threaded`` object with multiple "
"calling methods:"
msgstr ""
"Декоратор ``@threaded`` возвращает объект ``Threaded`` с несколькими "
"способами вызова:"

#: ../../source/threads.rst:88
msgid ""
"import time\n"
"from aiomisc import threaded\n"
"\n"
"\n"
"@threaded\n"
"def blocking_function():\n"
"    time.sleep(0.1)\n"
"    return \"result\"\n"
"\n"
"\n"
"async def main():\n"
"    # Async call (returns coroutine)\n"
"    result = await blocking_function()\n"
"\n"
"    # Explicit async call\n"
"    result = await blocking_function.async_call()\n"
"\n"
"    # Synchronous call (blocks current thread)\n"
"    result = blocking_function.sync_call()"
msgstr ""
"import time\n"
"from aiomisc import threaded\n"
"\n"
"\n"
"@threaded\n"
"def blocking_function():\n"
"    time.sleep(0.1)\n"
"    return \"result\"\n"
"\n"
"\n"
"async def main():\n"
"    # Асинхронный вызов (возвращает корутину)\n"
"    result = await blocking_function()\n"
"\n"
"    # Явный асинхронный вызов\n"
"    result = await blocking_function.async_call()\n"
"\n"
"    # Синхронный вызов (блокирует текущий поток)\n"
"    result = blocking_function.sync_call()"

#: ../../source/threads.rst:112
msgid "Works with methods"
msgstr "Работа с методами"

#: ../../source/threads.rst:114
msgid ""
"The decorator works correctly with instance methods, class methods, and "
"static methods:"
msgstr ""
"Декоратор корректно работает с методами экземпляра, методами класса и "
"статическими методами:"

#: ../../source/threads.rst:117
msgid ""
"from aiomisc import threaded\n"
"\n"
"\n"
"class MyClass:\n"
"    def __init__(self, value):\n"
"        self.value = value\n"
"\n"
"    @threaded\n"
"    def instance_method(self):\n"
"        return self.value\n"
"\n"
"    @threaded\n"
"    @classmethod\n"
"    def class_method(cls):\n"
"        return cls.__name__\n"
"\n"
"    @threaded\n"
"    @staticmethod\n"
"    def static_method(x):\n"
"        return x * 2\n"
"\n"
"\n"
"async def main():\n"
"    obj = MyClass(42)\n"
"    print(await obj.instance_method())       # 42\n"
"    print(await MyClass.class_method())      # MyClass\n"
"    print(await MyClass.static_method(21))   # 42"
msgstr ""

#: ../../source/threads.rst:149
msgid "``@aiomisc.threaded_separate``"
msgstr ""

#: ../../source/threads.rst:151
msgid ""
"Wraps a blocking function to run it in a new separate thread (not from "
"pool). Use this for long-running background tasks that would otherwise "
"occupy a thread pool slot for extended periods."
msgstr ""
"Оборачивает блокирующую функцию для выполнения в новом отдельном потоке "
"(не из пула). Используйте для долгих фоновых задач, которые иначе бы "
"занимали слот в пуле потоков на длительное время."

#: ../../source/threads.rst:155
msgid ""
"import asyncio\n"
"import time\n"
"import threading\n"
"import aiomisc\n"
"\n"
"\n"
"@aiomisc.threaded\n"
"def quick_task():\n"
"    \"\"\"Short task - uses thread pool\"\"\"\n"
"    time.sleep(0.1)\n"
"    return \"quick\"\n"
"\n"
"\n"
"@aiomisc.threaded_separate\n"
"def long_running_task(stop_event: threading.Event):\n"
"    \"\"\"Long task - runs in dedicated thread\"\"\"\n"
"    while not stop_event.is_set():\n"
"        print(\"Working...\")\n"
"        time.sleep(1)\n"
"    return \"finished\"\n"
"\n"
"\n"
"async def main():\n"
"    stop_event = threading.Event()\n"
"\n"
"    # Schedule stop after 5 seconds\n"
"    loop = asyncio.get_event_loop()\n"
"    loop.call_later(5, stop_event.set)\n"
"\n"
"    # Both run concurrently\n"
"    results = await asyncio.gather(\n"
"        quick_task(),\n"
"        long_running_task(stop_event),\n"
"    )\n"
"    print(results)  # ['quick', 'finished']\n"
"\n"
"\n"
"with aiomisc.entrypoint() as loop:\n"
"    loop.run_until_complete(main())"
msgstr ""
"import asyncio\n"
"import time\n"
"import threading\n"
"import aiomisc\n"
"\n"
"\n"
"@aiomisc.threaded\n"
"def quick_task():\n"
"    \"\"\"Короткая задача - использует пул потоков\"\"\"\n"
"    time.sleep(0.1)\n"
"    return \"quick\"\n"
"\n"
"\n"
"@aiomisc.threaded_separate\n"
"def long_running_task(stop_event: threading.Event):\n"
"    \"\"\"Длинная задача - запускается в выделенном потоке\"\"\"\n"
"    while not stop_event.is_set():\n"
"        print(\"Работаю...\")\n"
"        time.sleep(1)\n"
"    return \"finished\"\n"
"\n"
"\n"
"async def main():\n"
"    stop_event = threading.Event()\n"
"\n"
"    # Запланировать остановку через 5 секунд\n"
"    loop = asyncio.get_event_loop()\n"
"    loop.call_later(5, stop_event.set)\n"
"\n"
"    # Обе задачи выполняются параллельно\n"
"    results = await asyncio.gather(\n"
"        quick_task(),\n"
"        long_running_task(stop_event),\n"
"    )\n"
"    print(results)  # ['quick', 'finished']\n"
"\n"
"\n"
"with aiomisc.entrypoint() as loop:\n"
"    loop.run_until_complete(main())"

#: ../../source/threads.rst:199
msgid "Threaded iterators"
msgstr "Потоковые итераторы"

#: ../../source/threads.rst:202
msgid "``@aiomisc.threaded_iterable``"
msgstr ""

#: ../../source/threads.rst:204
msgid ""
"Wraps a blocking generator function to make it async-iterable. The "
"generator runs in a thread pool while yielding values to async code."
msgstr ""
"Оборачивает блокирующую функцию-генератор, делая её асинхронно-итерируемой. "
"Генератор выполняется в пуле потоков, передавая значения в async-код."

#: ../../source/threads.rst:209
msgid ""
"The generator uses lazy start - execution begins only when iteration "
"starts (first ``async for`` or ``__anext__()`` call), not when entering "
"the async context manager."
msgstr ""
"Генератор использует отложенный запуск - выполнение начинается только "
"при старте итерации (первый вызов ``async for`` или ``__anext__()``), а "
"не при входе в асинхронный контекстный менеджер."

#: ../../source/threads.rst:213
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"@aiomisc.threaded_iterable\n"
"def read_large_file(path):\n"
"    \"\"\"Read file line by line without blocking event loop\"\"\"\n"
"    with open(path, 'r') as f:\n"
"        for line in f:\n"
"            yield line.strip()\n"
"\n"
"\n"
"async def main():\n"
"    async with read_large_file('/etc/hosts') as lines:\n"
"        async for line in lines:\n"
"            print(line)\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"@aiomisc.threaded_iterable\n"
"def read_large_file(path):\n"
"    \"\"\"Чтение файла построчно без блокировки event loop\"\"\"\n"
"    with open(path, 'r') as f:\n"
"        for line in f:\n"
"            yield line.strip()\n"
"\n"
"\n"
"async def main():\n"
"    async with read_large_file('/etc/hosts') as lines:\n"
"        async for line in lines:\n"
"            print(line)\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../source/threads.rst:237
msgid "Buffer size control"
msgstr "Управление размером буфера"

#: ../../source/threads.rst:239
msgid ""
"Use ``max_size`` parameter to control backpressure. The generator thread "
"will block when the buffer is full:"
msgstr ""
"Используйте параметр ``max_size`` для управления обратным давлением. "
"Поток генератора будет заблокирован, когда буфер заполнен:"

#: ../../source/threads.rst:242
msgid ""
"import aiomisc\n"
"\n"
"\n"
"# Buffer holds at most 2 items\n"
"@aiomisc.threaded_iterable(max_size=2)\n"
"def produce_data():\n"
"    for i in range(1000):\n"
"        yield i  # Blocks when 2 items buffered"
msgstr ""
"import aiomisc\n"
"\n"
"\n"
"# Буфер содержит максимум 2 элемента\n"
"@aiomisc.threaded_iterable(max_size=2)\n"
"def produce_data():\n"
"    for i in range(1000):\n"
"        yield i  # Блокируется при 2 элементах в буфере"

#: ../../source/threads.rst:255
msgid "``@aiomisc.threaded_iterable_separate``"
msgstr ""

#: ../../source/threads.rst:257
msgid ""
"Same as ``@threaded_iterable`` but runs in a dedicated thread instead of "
"the thread pool. Use for long-running generators:"
msgstr ""
"То же, что и ``@threaded_iterable``, но выполняется в выделенном потоке "
"вместо пула потоков. Используйте для долгих генераторов:"

#: ../../source/threads.rst:260
msgid ""
"import aiomisc\n"
"\n"
"\n"
"@aiomisc.threaded_iterable_separate\n"
"def tail_file(path):\n"
"    \"\"\"Continuously read new lines from file\"\"\"\n"
"    with open(path, 'r') as f:\n"
"        f.seek(0, 2)  # Go to end\n"
"        while True:\n"
"            line = f.readline()\n"
"            if line:\n"
"                yield line.strip()"
msgstr ""
"import aiomisc\n"
"\n"
"\n"
"@aiomisc.threaded_iterable_separate\n"
"def tail_file(path):\n"
"    \"\"\"Непрерывное чтение новых строк из файла\"\"\"\n"
"    with open(path, 'r') as f:\n"
"        f.seek(0, 2)  # Перейти в конец\n"
"        while True:\n"
"            line = f.readline()\n"
"            if line:\n"
"                yield line.strip()"

#: ../../source/threads.rst:277
msgid "Cleanup with context managers"
msgstr "Очистка с помощью контекстных менеджеров"

#: ../../source/threads.rst:279
msgid ""
"For infinite generators, always use async context manager or call "
"``.close()``:"
msgstr ""
"Для бесконечных генераторов всегда используйте асинхронный контекстный "
"менеджер или вызывайте ``.close()``:"

#: ../../source/threads.rst:281
msgid ""
"import aiomisc\n"
"\n"
"\n"
"@aiomisc.threaded_iterable(max_size=2)\n"
"def infinite_generator():\n"
"    counter = 0\n"
"    while True:\n"
"        yield counter\n"
"        counter += 1\n"
"\n"
"\n"
"async def main():\n"
"    # Option 1: Context manager (recommended)\n"
"    async with infinite_generator() as gen:\n"
"        async for value in gen:\n"
"            if value >= 10:\n"
"                break  # Context manager handles cleanup\n"
"\n"
"    # Option 2: Manual cleanup\n"
"    gen = infinite_generator()\n"
"    async for value in gen:\n"
"        if value >= 10:\n"
"            break\n"
"    await gen.close()  # Must call close!"
msgstr ""
"import aiomisc\n"
"\n"
"\n"
"@aiomisc.threaded_iterable(max_size=2)\n"
"def infinite_generator():\n"
"    counter = 0\n"
"    while True:\n"
"        yield counter\n"
"        counter += 1\n"
"\n"
"\n"
"async def main():\n"
"    # Вариант 1: Контекстный менеджер (рекомендуется)\n"
"    async with infinite_generator() as gen:\n"
"        async for value in gen:\n"
"            if value >= 10:\n"
"                break  # Контекстный менеджер очистит ресурсы\n"
"\n"
"    # Вариант 2: Ручная очистка\n"
"    gen = infinite_generator()\n"
"    async for value in gen:\n"
"        if value >= 10:\n"
"            break\n"
"    await gen.close()  # Обязательно вызвать close!"

#: ../../source/threads.rst:310
msgid "``aiomisc.IteratorWrapper``"
msgstr ""

#: ../../source/threads.rst:312
msgid ""
"Wraps an existing generator to make it async-iterable. Useful when you "
"can't use decorators or need to specify a custom executor:"
msgstr ""
"Оборачивает существующий генератор, делая его асинхронно-итерируемым. "
"Полезно, когда нельзя использовать декораторы или нужно указать свой executor:"

#: ../../source/threads.rst:315
msgid ""
"import concurrent.futures\n"
"import aiomisc\n"
"\n"
"\n"
"def my_generator():\n"
"    for i in range(100):\n"
"        yield i\n"
"\n"
"\n"
"async def main():\n"
"    # Use default thread pool\n"
"    wrapper = aiomisc.IteratorWrapper(\n"
"        my_generator,\n"
"        max_size=10\n"
"    )\n"
"\n"
"    async with wrapper as gen:\n"
"        async for item in gen:\n"
"            print(item)\n"
"\n"
"    # Or use custom thread pool\n"
"    pool = concurrent.futures.ThreadPoolExecutor(2)\n"
"    wrapper = aiomisc.IteratorWrapper(\n"
"        my_generator,\n"
"        executor=pool,\n"
"        max_size=10\n"
"    )\n"
"\n"
"    async with wrapper as gen:\n"
"        async for item in gen:\n"
"            print(item)\n"
"\n"
"    pool.shutdown()"
msgstr ""
"import concurrent.futures\n"
"import aiomisc\n"
"\n"
"\n"
"def my_generator():\n"
"    for i in range(100):\n"
"        yield i\n"
"\n"
"\n"
"async def main():\n"
"    # Использовать пул потоков по умолчанию\n"
"    wrapper = aiomisc.IteratorWrapper(\n"
"        my_generator,\n"
"        max_size=10\n"
"    )\n"
"\n"
"    async with wrapper as gen:\n"
"        async for item in gen:\n"
"            print(item)\n"
"\n"
"    # Или использовать свой пул потоков\n"
"    pool = concurrent.futures.ThreadPoolExecutor(2)\n"
"    wrapper = aiomisc.IteratorWrapper(\n"
"        my_generator,\n"
"        executor=pool,\n"
"        max_size=10\n"
"    )\n"
"\n"
"    async with wrapper as gen:\n"
"        async for item in gen:\n"
"            print(item)\n"
"\n"
"    pool.shutdown()"

#: ../../source/threads.rst:353
msgid "``aiomisc.IteratorWrapperSeparate``"
msgstr ""

#: ../../source/threads.rst:355
msgid "Same as ``IteratorWrapper`` but runs the generator in a dedicated thread:"
msgstr "То же, что и ``IteratorWrapper``, но запускает генератор в выделенном потоке:"

#: ../../source/threads.rst:357
msgid ""
"import aiomisc\n"
"\n"
"\n"
"def blocking_generator():\n"
"    while True:\n"
"        yield \"data\"\n"
"\n"
"\n"
"async def main():\n"
"    wrapper = aiomisc.IteratorWrapperSeparate(\n"
"        blocking_generator,\n"
"        max_size=5\n"
"    )\n"
"\n"
"    async with wrapper as gen:\n"
"        count = 0\n"
"        async for item in gen:\n"
"            count += 1\n"
"            if count >= 100:\n"
"                break"
msgstr ""

#: ../../source/threads.rst:382
msgid "Calling async from threads"
msgstr "Вызов async из потоков"

#: ../../source/threads.rst:385
msgid "``aiomisc.sync_await``"
msgstr ""

#: ../../source/threads.rst:387
msgid ""
"Execute an async function synchronously from a thread. Automatically "
"detects the running event loop:"
msgstr ""
"Выполняет async-функцию синхронно из потока. Автоматически определяет "
"запущенный event loop:"

#: ../../source/threads.rst:390
#, python-brace-format
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"async def async_operation():\n"
"    await asyncio.sleep(0.1)\n"
"    return \"async result\"\n"
"\n"
"\n"
"@aiomisc.threaded\n"
"def thread_function():\n"
"    # Call async function from thread\n"
"    result = aiomisc.sync_await(async_operation())\n"
"    return f\"got: {result}\"\n"
"\n"
"\n"
"async def main():\n"
"    result = await thread_function()\n"
"    print(result)  # got: async result\n"
"\n"
"\n"
"with aiomisc.entrypoint() as loop:\n"
"    loop.run_until_complete(main())"
msgstr ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"async def async_operation():\n"
"    await asyncio.sleep(0.1)\n"
"    return \"async result\"\n"
"\n"
"\n"
"@aiomisc.threaded\n"
"def thread_function():\n"
"    # Вызов async-функции из потока\n"
"    result = aiomisc.sync_await(async_operation())\n"
"    return f\"got: {result}\"\n"
"\n"
"\n"
"async def main():\n"
"    result = await thread_function()\n"
"    print(result)  # got: async result\n"
"\n"
"\n"
"with aiomisc.entrypoint() as loop:\n"
"    loop.run_until_complete(main())"

#: ../../source/threads.rst:418
msgid "``aiomisc.sync_wait_coroutine``"
msgstr ""

#: ../../source/threads.rst:420
msgid "Lower-level function that requires explicit loop argument:"
msgstr "Низкоуровневая функция, требующая явный аргумент loop:"

#: ../../source/threads.rst:422
#, python-brace-format
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"async def fetch_data():\n"
"    await asyncio.sleep(0.1)\n"
"    return {\"key\": \"value\"}\n"
"\n"
"\n"
"@aiomisc.threaded\n"
"def process_in_thread(loop):\n"
"    # Explicit loop argument\n"
"    data = aiomisc.sync_wait_coroutine(loop, fetch_data())\n"
"    return data[\"key\"]\n"
"\n"
"\n"
"with aiomisc.entrypoint() as loop:\n"
"    result = loop.run_until_complete(process_in_thread(loop))\n"
"    print(result)  # value"
msgstr ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"async def fetch_data():\n"
"    await asyncio.sleep(0.1)\n"
"    return {\"key\": \"value\"}\n"
"\n"
"\n"
"@aiomisc.threaded\n"
"def process_in_thread(loop):\n"
"    # Явный аргумент loop\n"
"    data = aiomisc.sync_wait_coroutine(loop, fetch_data())\n"
"    return data[\"key\"]\n"
"\n"
"\n"
"with aiomisc.entrypoint() as loop:\n"
"    result = loop.run_until_complete(process_in_thread(loop))\n"
"    print(result)  # value"

#: ../../source/threads.rst:446
msgid "``aiomisc.FromThreadChannel``"
msgstr ""

#: ../../source/threads.rst:448
msgid ""
"A channel for sending data from threads to async code. Unlike "
"``IteratorWrapper``, you control when and what to send:"
msgstr ""
"Канал для отправки данных из потоков в async-код. В отличие от "
"``IteratorWrapper``, вы контролируете когда и что отправлять:"

#: ../../source/threads.rst:451
#, python-brace-format
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"async def consumer(channel: aiomisc.FromThreadChannel):\n"
"    async for item in channel:\n"
"        print(f\"Received: {item}\")\n"
"\n"
"\n"
"@aiomisc.threaded_separate\n"
"def producer(channel: aiomisc.FromThreadChannel):\n"
"    for i in range(5):\n"
"        channel.put(i)  # Send to async consumer\n"
"    channel.close()  # Signal end of data\n"
"\n"
"\n"
"async def main():\n"
"    channel = aiomisc.FromThreadChannel(max_size=2)\n"
"\n"
"    await asyncio.gather(\n"
"        consumer(channel),\n"
"        producer(channel),\n"
"    )\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"async def consumer(channel: aiomisc.FromThreadChannel):\n"
"    async for item in channel:\n"
"        print(f\"Получено: {item}\")\n"
"\n"
"\n"
"@aiomisc.threaded_separate\n"
"def producer(channel: aiomisc.FromThreadChannel):\n"
"    for i in range(5):\n"
"        channel.put(i)  # Отправка в async-потребитель\n"
"    channel.close()  # Сигнал о конце данных\n"
"\n"
"\n"
"async def main():\n"
"    channel = aiomisc.FromThreadChannel(max_size=2)\n"
"\n"
"    await asyncio.gather(\n"
"        consumer(channel),\n"
"        producer(channel),\n"
"    )\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../source/threads.rst:482
msgid "``contextvars`` support"
msgstr "Поддержка ``contextvars``"

#: ../../source/threads.rst:484
msgid "All decorators automatically copy context variables to the thread:"
msgstr "Все декораторы автоматически копируют контекстные переменные в поток:"

#: ../../source/threads.rst:486
#, python-brace-format
msgid ""
"import asyncio\n"
"import contextvars\n"
"import aiomisc\n"
"\n"
"\n"
"request_id = contextvars.ContextVar(\"request_id\")\n"
"\n"
"\n"
"@aiomisc.threaded\n"
"def log_with_context(message):\n"
"    print(f\"[{request_id.get()}] {message}\")\n"
"\n"
"\n"
"async def handle_request(req_id):\n"
"    request_id.set(req_id)\n"
"    await log_with_context(\"Processing request\")\n"
"\n"
"\n"
"async def main():\n"
"    await asyncio.gather(\n"
"        handle_request(\"req-001\"),\n"
"        handle_request(\"req-002\"),\n"
"        handle_request(\"req-003\"),\n"
"    )\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import contextvars\n"
"import aiomisc\n"
"\n"
"\n"
"request_id = contextvars.ContextVar(\"request_id\")\n"
"\n"
"\n"
"@aiomisc.threaded\n"
"def log_with_context(message):\n"
"    print(f\"[{request_id.get()}] {message}\")\n"
"\n"
"\n"
"async def handle_request(req_id):\n"
"    request_id.set(req_id)\n"
"    await log_with_context(\"Обработка запроса\")\n"
"\n"
"\n"
"async def main():\n"
"    await asyncio.gather(\n"
"        handle_request(\"req-001\"),\n"
"        handle_request(\"req-002\"),\n"
"        handle_request(\"req-003\"),\n"
"    )\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../source/threads.rst:517
msgid "Output::"
msgstr "Вывод::"

#: ../../source/threads.rst:519
msgid ""
"[req-001] Processing request\n"
"[req-002] Processing request\n"
"[req-003] Processing request"
msgstr ""

#: ../../source/threads.rst:526
msgid ""
"Context variables are copied to threads, so modifications in threads "
"don't affect the parent context."
msgstr ""
"Контекстные переменные копируются в потоки, поэтому изменения в потоках "
"не влияют на родительский контекст."

#: ../../source/threads.rst:531
msgid "``aiomisc.ThreadPoolExecutor``"
msgstr ""

#: ../../source/threads.rst:533
msgid "A fast thread pool implementation used by aiomisc internally."
msgstr "Быстрая реализация пула потоков, используемая внутри aiomisc."

#: ../../source/threads.rst:535
msgid "Manual setup:"
msgstr "Ручная настройка:"

#: ../../source/threads.rst:537
msgid ""
"import asyncio\n"
"from aiomisc import ThreadPoolExecutor\n"
"\n"
"loop = asyncio.get_event_loop()\n"
"thread_pool = ThreadPoolExecutor(4)\n"
"loop.set_default_executor(thread_pool)"
msgstr ""

#: ../../source/threads.rst:549
msgid ""
"The ``entrypoint`` context manager sets this automatically. Use the "
"``pool_size`` argument to control thread pool size:"
msgstr ""
"Контекстный менеджер ``entrypoint`` устанавливает это автоматически. "
"Используйте аргумент ``pool_size`` для управления размером пула потоков:"

#: ../../source/threads.rst:552
msgid ""
"with aiomisc.entrypoint(pool_size=8) as loop:\n"
"    ..."
msgstr ""
