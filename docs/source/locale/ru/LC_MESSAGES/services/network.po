# Russian translations for aiomisc package.
# Copyright (C) 2026, Dmitry Orlov
# This file is distributed under the same license as the aiomisc package.
#
msgid ""
msgstr ""
"Project-Id-Version: aiomisc 17.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-09 00:31+0100\n"
"PO-Revision-Date: 2026-02-09 12:00+0100\n"
"Last-Translator: \n"
"Language: ru\n"
"Language-Team: ru <LL@li.org>\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/services/network.rst:2
msgid "Network Services"
msgstr "Сетевые сервисы"

#: ../../source/services/network.rst:4
msgid ""
"This section covers network-related services including TCP, UDP, and TLS "
"servers and clients."
msgstr ""
"В этом разделе рассматриваются сетевые сервисы, включая TCP, UDP и TLS "
"серверы и клиенты."

#: ../../source/services/network.rst:11
msgid "``TCPServer``"
msgstr "``TCPServer``"

#: ../../source/services/network.rst:13
msgid ""
"``TCPServer`` - it's a base class for writing TCP servers. Just implement"
" ``handle_client(reader, writer)`` to use it."
msgstr ""
"``TCPServer`` — базовый класс для написания TCP-серверов. Для "
"использования достаточно реализовать ``handle_client(reader, writer)``."

#: ../../source/services/network.rst:16
msgid ""
"import asyncio\n"
"import logging\n"
"from aiomisc import entrypoint\n"
"from aiomisc.service import TCPServer\n"
"\n"
"\n"
"log = logging.getLogger(__name__)\n"
"\n"
"\n"
"class EchoServer(TCPServer):\n"
"    async def handle_client(self, reader: asyncio.StreamReader,\n"
"                            writer: asyncio.StreamWriter):\n"
"        while not reader.at_eof():\n"
"            writer.write(await reader.read(255))\n"
"\n"
"        log.info(\"Client connection closed\")\n"
"\n"
"\n"
"async def echo_client(host, port):\n"
"    reader, writer = await asyncio.open_connection(host=host, port=port)\n"
"    writer.write(b\"hello\\n\")\n"
"    assert await reader.readline() == b\"hello\\n\"\n"
"\n"
"    writer.write(b\"world\\n\")\n"
"    assert await reader.readline() == b\"world\\n\"\n"
"\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"\n"
"with entrypoint(\n"
"    EchoServer(address='localhost', port=8901),\n"
") as loop:\n"
"    loop.run_until_complete(echo_client(\"localhost\", 8901))"
msgstr ""

#: ../../source/services/network.rst:58
msgid "``UDPServer``"
msgstr "``UDPServer``"

#: ../../source/services/network.rst:60
msgid ""
"``UDPServer`` - it's a base class for writing UDP servers. Just implement"
" ``handle_datagram(data, addr)`` to use it."
msgstr ""
"``UDPServer`` — базовый класс для написания UDP-серверов. Для "
"использования достаточно реализовать ``handle_datagram(data, addr)``."

#: ../../source/services/network.rst:63
msgid ""
"class UDPPrinter(UDPServer):\n"
"    async def handle_datagram(self, data: bytes, addr):\n"
"        print(addr, '->', data)\n"
"\n"
"\n"
"with entrypoint(UDPPrinter(address='localhost', port=3000)) as loop:\n"
"    loop.run_forever()"
msgstr ""

#: ../../source/services/network.rst:75
msgid "``TLSServer``"
msgstr "``TLSServer``"

#: ../../source/services/network.rst:77
msgid ""
"``TLSServer`` - it's a base class for writing TCP servers with TLS. Just "
"implement ``handle_client(reader, writer)`` to use it."
msgstr ""
"``TLSServer`` — базовый класс для написания TCP-серверов с TLS. Для "
"использования достаточно реализовать ``handle_client(reader, writer)``."

#: ../../source/services/network.rst:80
msgid ""
"class SecureEchoServer(TLSServer):\n"
"    async def handle_client(self, reader: asyncio.StreamReader,\n"
"                            writer: asyncio.StreamWriter):\n"
"        while True:\n"
"            writer.write(await reader.readline())\n"
"\n"
"service = SecureEchoServer(\n"
"    address='localhost',\n"
"    port=8900,\n"
"    ca='ca.pem',\n"
"    cert='cert.pem',\n"
"    key='key.pem',\n"
"    verify=False,\n"
")\n"
"\n"
"with entrypoint(service) as loop:\n"
"    loop.run_forever()"
msgstr ""

#: ../../source/services/network.rst:104
msgid "``TCPClient``"
msgstr "``TCPClient``"

#: ../../source/services/network.rst:106
msgid ""
"``TCPClient`` - it's a base class for writing TCP clients. Just implement"
" ``handle_connection(reader, writer)`` to use it."
msgstr ""
"``TCPClient`` — базовый класс для написания TCP-клиентов. Для "
"использования достаточно реализовать ``handle_connection(reader, writer)``."

#: ../../source/services/network.rst:109
msgid ""
"import asyncio\n"
"import logging\n"
"from aiomisc import entrypoint\n"
"from aiomisc.service import TCPServer, TCPClient\n"
"\n"
"log = logging.getLogger(__name__)\n"
"\n"
"\n"
"class EchoServer(TCPServer):\n"
"    async def handle_client(self, reader: asyncio.StreamReader,\n"
"                            writer: asyncio.StreamWriter):\n"
"        while not reader.at_eof():\n"
"            writer.write(await reader.read(255))\n"
"\n"
"        log.info(\"Client connection closed\")\n"
"\n"
"\n"
"class EchoClient(TCPClient):\n"
"\n"
"    async def handle_connection(self, reader: asyncio.StreamReader,\n"
"                                writer: asyncio.StreamWriter) -> None:\n"
"        writer.write(b\"hello\\n\")\n"
"        assert await reader.readline() == b\"hello\\n\"\n"
"\n"
"        writer.write(b\"world\\n\")\n"
"        assert await reader.readline() == b\"world\\n\"\n"
"\n"
"        writer.write_eof()\n"
"        writer.close()\n"
"        await writer.wait_closed()\n"
"\n"
"\n"
"with entrypoint(\n"
"    EchoServer(address='localhost', port=8901),\n"
"    EchoClient(address='localhost', port=8901),\n"
") as loop:\n"
"    loop.run_until_complete(asyncio.sleep(0.1))"
msgstr ""

#: ../../source/services/network.rst:152
msgid "``TLSClient``"
msgstr "``TLSClient``"

#: ../../source/services/network.rst:154
msgid ""
"``TLSClient`` - it's a base class for writing TLS clients. Just implement"
" ``handle_connection(reader, writer)`` to use it."
msgstr ""
"``TLSClient`` — базовый класс для написания TLS-клиентов. Для "
"использования достаточно реализовать ``handle_connection(reader, writer)``."

#: ../../source/services/network.rst:157
msgid ""
"import asyncio\n"
"import logging\n"
"from aiomisc import entrypoint\n"
"from aiomisc.service import TCPServer, TCPClient\n"
"\n"
"log = logging.getLogger(__name__)\n"
"\n"
"\n"
"class EchoServer(TLSServer):\n"
"    async def handle_client(self, reader: asyncio.StreamReader,\n"
"                            writer: asyncio.StreamWriter):\n"
"        while not reader.at_eof():\n"
"            writer.write(await reader.read(255))\n"
"\n"
"        log.info(\"Client connection closed\")\n"
"\n"
"\n"
"class EchoClient(TLSClient):\n"
"\n"
"    async def handle_connection(self, reader: asyncio.StreamReader,\n"
"                                writer: asyncio.StreamWriter) -> None:\n"
"        writer.write(b\"hello\\n\")\n"
"        assert await reader.readline() == b\"hello\\n\"\n"
"\n"
"        writer.write(b\"world\\n\")\n"
"        assert await reader.readline() == b\"world\\n\"\n"
"\n"
"        writer.write_eof()\n"
"        writer.close()\n"
"        await writer.wait_closed()\n"
"\n"
"\n"
"with entrypoint(\n"
"    EchoServer(\n"
"        address='localhost', port=8901,\n"
"        ca='ca.pem',\n"
"        cert='server.pem',\n"
"        key='server.key',\n"
"    ),\n"
"    EchoClient(\n"
"        address='localhost', port=8901,\n"
"        ca='ca.pem',\n"
"        cert='client.pem',\n"
"        key='client.key',\n"
"    ),\n"
") as loop:\n"
"    loop.run_until_complete(asyncio.sleep(0.1))"
msgstr ""

#: ../../source/services/network.rst:209
msgid "``RobustTCPClient``"
msgstr "``RobustTCPClient``"

#: ../../source/services/network.rst:211
msgid ""
"``RobustTCPClient`` - it's a base class for writing TCP clients with "
"auto-reconnection when connection lost. Just implement "
"``handle_connection(reader, writer)`` to use it."
msgstr ""
"``RobustTCPClient`` — базовый класс для написания TCP-клиентов с "
"автоматическим переподключением при потере соединения. Для использования "
"достаточно реализовать ``handle_connection(reader, writer)``."

#: ../../source/services/network.rst:215
msgid ""
"import asyncio\n"
"import logging\n"
"from aiomisc import entrypoint\n"
"from aiomisc.service import TCPServer, RobustTCPClient\n"
"\n"
"log = logging.getLogger(__name__)\n"
"\n"
"\n"
"class EchoServer(TCPServer):\n"
"    async def handle_client(self, reader: asyncio.StreamReader,\n"
"                            writer: asyncio.StreamWriter):\n"
"        while not reader.at_eof():\n"
"            writer.write(await reader.read(255))\n"
"\n"
"        log.info(\"Client connection closed\")\n"
"\n"
"\n"
"class EchoClient(RobustTCPClient):\n"
"\n"
"    async def handle_connection(self, reader: asyncio.StreamReader,\n"
"                                writer: asyncio.StreamWriter) -> None:\n"
"        writer.write(b\"hello\\n\")\n"
"        assert await reader.readline() == b\"hello\\n\"\n"
"\n"
"        writer.write(b\"world\\n\")\n"
"        assert await reader.readline() == b\"world\\n\"\n"
"\n"
"        writer.write_eof()\n"
"        writer.close()\n"
"        await writer.wait_closed()\n"
"\n"
"\n"
"with entrypoint(\n"
"    EchoServer(address='localhost', port=8901),\n"
"    EchoClient(address='localhost', port=8901),\n"
") as loop:\n"
"    loop.run_until_complete(asyncio.sleep(0.1))"
msgstr ""

#: ../../source/services/network.rst:258
msgid "``RobustTLSClient``"
msgstr "``RobustTLSClient``"

#: ../../source/services/network.rst:260
msgid ""
"``RobustTLSClient`` - it's a base class for writing TLS clients with "
"auto-reconnection when connection lost. Just implement "
"``handle_connection(reader, writer)`` to use it."
msgstr ""
"``RobustTLSClient`` — базовый класс для написания TLS-клиентов с "
"автоматическим переподключением при потере соединения. Для использования "
"достаточно реализовать ``handle_connection(reader, writer)``."

#: ../../source/services/network.rst:264
msgid ""
"import asyncio\n"
"import logging\n"
"from aiomisc import entrypoint\n"
"from aiomisc.service import TCPServer, RobustTCPClient\n"
"\n"
"log = logging.getLogger(__name__)\n"
"\n"
"\n"
"class EchoServer(TLSServer):\n"
"    async def handle_client(self, reader: asyncio.StreamReader,\n"
"                            writer: asyncio.StreamWriter):\n"
"        while not reader.at_eof():\n"
"            writer.write(await reader.read(255))\n"
"\n"
"        log.info(\"Client connection closed\")\n"
"\n"
"\n"
"class EchoClient(RobustTLSClient):\n"
"\n"
"    async def handle_connection(self, reader: asyncio.StreamReader,\n"
"                                writer: asyncio.StreamWriter) -> None:\n"
"        writer.write(b\"hello\\n\")\n"
"        assert await reader.readline() == b\"hello\\n\"\n"
"\n"
"        writer.write(b\"world\\n\")\n"
"        assert await reader.readline() == b\"world\\n\"\n"
"\n"
"        writer.write_eof()\n"
"        writer.close()\n"
"        await writer.wait_closed()\n"
"\n"
"\n"
"with entrypoint(\n"
"    EchoServer(\n"
"        address='localhost', port=8901,\n"
"        ca='ca.pem',\n"
"        cert='server.pem',\n"
"        key='server.key',\n"
"    ),\n"
"    EchoClient(\n"
"        address='localhost', port=8901,\n"
"        ca='ca.pem',\n"
"        cert='client.pem',\n"
"        key='client.key',\n"
"    ),\n"
") as loop:\n"
"    loop.run_until_complete(asyncio.sleep(0.1))"
msgstr ""

