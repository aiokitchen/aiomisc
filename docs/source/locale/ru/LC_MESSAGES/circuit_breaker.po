# Translations template for aiomisc.
# Copyright (C) 2021
# This file is distributed under the same license as the aiomisc project.
# Dmitry Orlov <me@mosquito.su>, 2022.
msgid ""
msgstr ""
"Project-Id-Version:  14\n"
"Report-Msgid-Bugs-To: me@mosquito.su\n"
"POT-Creation-Date: 2022-12-29 11:36+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dmitry Orlov <me@mosquito.su>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../source/circuit_breaker.rst:2
msgid "Circuit Breaker"
msgstr "Предохранитель"

#: ../../source/circuit_breaker.rst:4
msgid ""
"`Circuit breaker is a design pattern`_ used in software development. It "
"is used to detect failures and encapsulates the logic of preventing a "
"failure from constantly recurring, during maintenance, temporary external"
" system failure, or unexpected system difficulties."
msgstr ""
"`Предохранитель - это шаблон проектирования`_, используемый при "
"разработке программного обеспечения. Он используется для обнаружения "
"сбоев и инкапсулирует логику предотвращения постоянного повторения сбоя "
"во время обслуживания, временного сбоя внешней системы или неожиданных "
"системных проблем."

#: ../../source/circuit_breaker.rst:9
msgid ""
"The following example demonstrates the simple usage of the current "
"implementation of ``aiomisc.CircuitBreaker``. An instance of "
"``CircuitBreaker`` collecting function call statistics. That contains "
"counters mapping with successful and failed function calls. Function "
"calls must be wrapped by the `CircuitBreaker.call` the method to gather "
"it."
msgstr ""
"Следующий пример демонстрирует простое использование текущей реализации "
"``aiomisc.CircuitBreaker``. Экземпляр ``CircuitBreaker``, собирает "
"статистику вызовов функций. Он содержит счетчики которые содержат "
"успешные и неудачные вызовы функции. Вызовы функций должны быть обернуты "
"методом `CircuitBreaker.call`, чтобы собирать статистику."

#: ../../source/circuit_breaker.rst:16
msgid "Usage example:"
msgstr "Пример использования:"

#: ../../source/circuit_breaker.rst:18
#, python-format
msgid ""
"from aiohttp import web, ClientSession\n"
"from aiomisc.service.aiohttp import AIOHTTPService\n"
"import aiohttp\n"
"import aiomisc\n"
"\n"
"\n"
"async def public_gists(request):\n"
"    async with aiohttp.ClientSession() as session:\n"
"        # Using as context manager\n"
"        with request.app[\"github_cb\"].context():\n"
"            url = 'https://api.github.com/gists/public'\n"
"            async with session.get(url) as response:\n"
"                data = await response.text()\n"
"\n"
"    return web.Response(\n"
"        text=data,\n"
"        headers={\"Content-Type\": \"application/json\"}\n"
"    )\n"
"\n"
"\n"
"class API(AIOHTTPService):\n"
"    async def create_application(self):\n"
"        app = web.Application()\n"
"        app.add_routes([web.get('/', public_gists)])\n"
"\n"
"        # When 30% errors in 20 seconds\n"
"        # Will be broken for 5 seconds\n"
"        app[\"github_cb\"] = aiomisc.CircuitBreaker(\n"
"            error_ratio=0.2,\n"
"            response_time=20,\n"
"            exceptions=[aiohttp.ClientError],\n"
"            broken_time=5\n"
"        )\n"
"\n"
"        return app\n"
"\n"
"\n"
"async def main():\n"
"    async with ClientSession() as session:\n"
"        async with session.get(\"http://localhost:8080/\") as response:\n"
"            assert response.headers\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    with aiomisc.entrypoint(API(port=8080)) as loop:\n"
"        loop.run_until_complete(main())"
msgstr ""
"from aiohttp import web, ClientSession\n"
"from aiomisc.service.aiohttp import AIOHTTPService\n"
"import aiohttp\n"
"import aiomisc\n"
"\n"
"\n"
"async def public_gists(request):\n"
"    async with aiohttp.ClientSession() as session:\n"
"        # Используем как контекстный менеджер\n"
"        with request.app[\"github_cb\"].context():\n"
"            url = 'https://api.github.com/gists/public'\n"
"            async with session.get(url) as response:\n"
"                data = await response.text()\n"
"\n"
"    return web.Response(\n"
"        text=data,\n"
"        headers={\"Content-Type\": \"application/json\"}\n"
"    )\n"
"\n"
"\n"
"class API(AIOHTTPService):\n"
"    async def create_application(self):\n"
"        app = web.Application()\n"
"        app.add_routes([web.get('/', public_gists)])\n"
"\n"
"        # Если ошибок 30% за 20 секунд\n"
"        # Сломаемся на 5 секунд\n"
"        app[\"github_cb\"] = aiomisc.CircuitBreaker(\n"
"            error_ratio=0.2,\n"
"            response_time=20,\n"
"            exceptions=[aiohttp.ClientError],\n"
"            broken_time=5\n"
"        )\n"
"\n"
"        return app\n"
"\n"
"\n"
"async def main():\n"
"    async with ClientSession() as session:\n"
"        async with session.get(\"http://localhost:8080/\") as response:\n"
"            assert response.headers\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    with aiomisc.entrypoint(API(port=8080)) as loop:\n"
"        loop.run_until_complete(main())"

#: ../../source/circuit_breaker.rst:72
msgid "The `CircuitBreaker` object might be one of three states:"
msgstr "Объект `CircuitBreaker` может находится в одном из трех состояний:"

#: ../../source/circuit_breaker.rst:74
msgid "**PASSING**"
msgstr "**PASSING** - аналогия с \"ток протекает\" (прим. пер.)"

#: ../../source/circuit_breaker.rst:75
msgid "**BROKEN**"
msgstr "**BROKEN** - аналогия со \"сгоревшим предохранителем\" (прим. пер.)"

#: ../../source/circuit_breaker.rst:76
msgid "**RECOVERING**"
msgstr "**RECOVERING** - восстанавливается"

#: ../../source/circuit_breaker.rst:80
msgid ""
"**PASSING** means all calls will be passed as is and statistics will be "
"gathered. The next state will be determined after collecting statistics "
"for ``passing_time`` seconds. If an effective error ratio is greater than"
" `error_ratio` then the next state will be set to **BROKEN**, otherwise, "
"it will remain unchanged."
msgstr ""
"**PASSING** означает, что все вызовы будут переданы как есть, но будет "
"собираться статистика. Следующее состояние будет определено после сбора "
"статистики за ``passing_time`` секунд. Если эффективный коэффициент "
"ошибок больше чем `error_ratio`, тогда следующее состояние будет "
"установлено как **BROKEN** (предохранитель перегорел, прим. пер.), в "
"противном случае оно останется неизменным."

#: ../../source/circuit_breaker.rst:86
msgid ""
"**BROKEN** means the wrapped function won't be called and "
"``CircuitBroken`` an exception will be raised instead. **BROKEN** state "
"will be kept for ``broken_time`` seconds."
msgstr ""
"**BROKEN** означает, что обернутая функция не будет вызываться и вместо "
"нее будет брошено исключение ``CircuitBroken``. Состояние **BROKEN** "
"будет сохраняться в течение ``broken_time`` секунд."

#: ../../source/circuit_breaker.rst:92
msgid ""
"``CircuitBroken`` exception is a consequence of **BROKEN** or "
"**RECOVERY** state and never be accounted for in the statistic."
msgstr ""
"Исключение ``CircuitBroken`` является следствием состояния **BROKEN** или"
" **RECOVERY** и никогда не учитывается в статистике."

#: ../../source/circuit_breaker.rst:95
msgid ""
"After that, it changes to **RECOVERING** state. While in that state, a "
"small sample of the wrapped function calls will be executed and "
"statistics will be gathered. If the effective error ratio after "
"``recovery_time`` is lower than ``error_ratio`` then the next state will "
"be set to **PASSING**, and otherwise - to **BROKEN**."
msgstr ""
"После этого предохранитель переходит в состояние **RECOVERING**. В этом "
"состоянии фактически будет выполняться небольшая выборка обернутых "
"вызовов функции, но будет собираться статистика. Если эффективный "
"коэффициент ошибок после ``recovery_time`` ниже, чем ``error_ratio``, то "
"следующее состояние будет установлено в **PASSING**, в противном случае "
"снова **BROKEN**."

#: ../../source/circuit_breaker.rst:101
msgid ""
"Argument ``exception_inspector`` is a function that is called whenever an"
" exception from the list of monitored exceptions occurs. When ``False`` "
"will be returned, this exception will be ignored."
msgstr ""
"Аргумент ``exception_inspector`` это функция, которая вызывается всякий "
"раз, когда происходит исключение из списка отслеживаемых исключений. Если"
" она возвращает ``False`` - исключение будет проигнорировано."

#: ../../source/circuit_breaker.rst:109
msgid "cutout"
msgstr "Декоратор ``cutout`` - \"рубильник\""

#: ../../source/circuit_breaker.rst:111
msgid "Decorator for ``CircuitBreaker`` which wrapping functions."
msgstr ""
"Декоратор оборачивающий функцию таким образом, что все вызовы проходят "
"через предохраннитель, а именно через экземпляр ``CircuitBreaker`` для "
"этой функции."

#: ../../source/circuit_breaker.rst:113
#, python-format
msgid ""
"from aiohttp import web, ClientSession\n"
"from aiomisc.service.aiohttp import AIOHTTPService\n"
"import aiohttp\n"
"import aiomisc\n"
"\n"
"\n"
"# When 20% errors in 30 seconds\n"
"# Will be broken on 30 seconds\n"
"@aiomisc.cutout(0.2, 30, aiohttp.ClientError)\n"
"async def fetch(session, url):\n"
"    async with session.get(url) as response:\n"
"        return await response.text()\n"
"\n"
"\n"
"async def public_gists(request):\n"
"    async with aiohttp.ClientSession() as session:\n"
"        data = await fetch(\n"
"            session,\n"
"            'https://api.github.com/gists/public'\n"
"        )\n"
"\n"
"    return web.Response(\n"
"        text=data,\n"
"        headers={\"Content-Type\": \"application/json\"}\n"
"    )\n"
"\n"
"\n"
"class API(AIOHTTPService):\n"
"    async def create_application(self):\n"
"        app = web.Application()\n"
"        app.add_routes([web.get('/', public_gists)])\n"
"        return app\n"
"\n"
"\n"
"async def main():\n"
"    async with ClientSession() as session:\n"
"        async with session.get(\"http://localhost:8080/\") as response:\n"
"            assert response.headers\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    with aiomisc.entrypoint(API(port=8080)) as loop:\n"
"        loop.run_until_complete(main())"
msgstr ""
"from aiohttp import web, ClientSession\n"
"from aiomisc.service.aiohttp import AIOHTTPService\n"
"import aiohttp\n"
"import aiomisc\n"
"\n"
"\n"
"# Если 20% ошибок за 30 секунд\n"
"# Сломаемся на 30 секунд\n"
"@aiomisc.cutout(0.2, 30, aiohttp.ClientError)\n"
"async def fetch(session, url):\n"
"    async with session.get(url) as response:\n"
"        return await response.text()\n"
"\n"
"\n"
"async def public_gists(request):\n"
"    async with aiohttp.ClientSession() as session:\n"
"        data = await fetch(\n"
"            session,\n"
"            'https://api.github.com/gists/public'\n"
"        )\n"
"\n"
"    return web.Response(\n"
"        text=data,\n"
"        headers={\"Content-Type\": \"application/json\"}\n"
"    )\n"
"\n"
"\n"
"class API(AIOHTTPService):\n"
"    async def create_application(self):\n"
"        app = web.Application()\n"
"        app.add_routes([web.get('/', public_gists)])\n"
"        return app\n"
"\n"
"\n"
"async def main():\n"
"    async with ClientSession() as session:\n"
"        async with session.get(\"http://localhost:8080/\") as response:\n"
"            assert response.headers\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    with aiomisc.entrypoint(API(port=8080)) as loop:\n"
"        loop.run_until_complete(main())"
