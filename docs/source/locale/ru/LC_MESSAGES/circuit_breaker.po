# Translations template for aiomisc.
# Copyright (C) 2021
# This file is distributed under the same license as the aiomisc project.
# Dmitry Orlov <me@mosquito.su>, 2021.
msgid ""
msgstr ""
"Project-Id-Version:  14\n"
"Report-Msgid-Bugs-To: me@mosquito.su\n"
"POT-Creation-Date: 2021-10-15 17:18+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dmitry Orlov <me@mosquito.su>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../source/circuit_breaker.rst:2
msgid "Circuit Breaker"
msgstr "Предохранитель"

#: ../../source/circuit_breaker.rst:4
msgid ""
"`Circuit breaker is a design pattern`_ used in software development. It "
"is used to detect failures and encapsulates the logic of preventing a "
"failure from constantly recurring, during maintenance, temporary external"
" system failure, or unexpected system difficulties."
msgstr ""
"`Предохранитель - это шаблон проектирования`_, используемый при "
"разработке программного обеспечения. Он используется для обнаружения "
"сбоев и инкапсулирует логику предотвращения постоянного повторения сбоя "
"во время обслуживания, временного сбоя внешней системы или неожиданных "
"системных проблем."

#: ../../source/circuit_breaker.rst:9
msgid ""
"The following example demonstrates the simple usage of the current "
"implementation of ``aiomisc.CircuitBreaker``. An instance of "
"``CircuitBreaker`` collecting function call statistics. That contains "
"counters mapping with successful and failed function calls. Function "
"calls must be wrapped by the `CircuitBreaker.call` the method to gather "
"it."
msgstr ""
"Следующий пример демонстрирует простое использование текущей реализации "
"``aiomisc.CircuitBreaker``. Экземпляр ``CircuitBreaker``, собирает "
"статистику вызовов функций. Он содержит счетчики которые содержат "
"успешные и неудачные вызовы функции. Вызовы функций должны быть обернуты "
"методом `CircuitBreaker.call`, чтобы собирать статистику."

#: ../../source/circuit_breaker.rst:16
msgid "Usage example:"
msgstr "Пример использования:"

#: ../../source/circuit_breaker.rst:72
msgid "The `CircuitBreaker` object might be one of three states:"
msgstr "Объект `CircuitBreaker` может находится в одном из трех состояний:"

#: ../../source/circuit_breaker.rst:74
msgid "**PASSING**"
msgstr "**PASSING** - аналогия с \"ток протекает\" (прим. пер.)"

#: ../../source/circuit_breaker.rst:75
msgid "**BROKEN**"
msgstr "**BROKEN** - аналогия со \"сгоревшим предохранителем\" (прим. пер.)"

#: ../../source/circuit_breaker.rst:76
msgid "**RECOVERING**"
msgstr "**RECOVERING** - восстанавливается"

#: ../../source/circuit_breaker.rst:80
msgid ""
"**PASSING** means all calls will be passed as is and statistics will be "
"gathered. The next state will be determined after collecting statistics "
"for ``passing_time`` seconds. If an effective error ratio is greater than"
" `error_ratio` then the next state will be set to **BROKEN**, otherwise, "
"it will remain unchanged."
msgstr ""
"**PASSING** означает, что все вызовы будут переданы как есть, но будет "
"собираться статистика. Следующее состояние будет определено после сбора "
"статистики за ``passing_time`` секунд. Если эффективный коэффициент "
"ошибок больше чем `error_ratio`, тогда следующее состояние будет "
"установлено как **BROKEN** (предохранитель перегорел, прим. пер.), в "
"противном случае оно останется неизменным."

#: ../../source/circuit_breaker.rst:86
msgid ""
"**BROKEN** means the wrapped function won't be called and "
"``CircuitBroken`` an exception will be raised instead. **BROKEN** state "
"will be kept for ``broken_time`` seconds."
msgstr ""
"**BROKEN** означает, что обернутая функция не будет вызываться и вместо "
"нее будет брошено исключение ``CircuitBroken``. Состояние **BROKEN** "
"будет сохраняться в течение ``broken_time`` секунд."

#: ../../source/circuit_breaker.rst:92
msgid ""
"``CircuitBroken`` exception is a consequence of **BROKEN** or "
"**RECOVERY** state and never be accounted for in the statistic."
msgstr ""
"Исключение ``CircuitBroken`` является следствием состояния **BROKEN** или"
" **RECOVERY** и никогда не учитывается в статистике."

#: ../../source/circuit_breaker.rst:95
msgid ""
"After that, it changes to **RECOVERING** state. While in that state, a "
"small sample of the wrapped function calls will be executed and "
"statistics will be gathered. If the effective error ratio after "
"``recovery_time`` is lower than ``error_ratio`` then the next state will "
"be set to **PASSING**, and otherwise - to **BROKEN**."
msgstr ""
"После этого предохранитель переходит в состояние **RECOVERING**. В этом "
"состоянии фактически будет выполняться небольшая выборка обернутых "
"вызовов функции, но будет собираться статистика. Если эффективный "
"коэффициент ошибок после ``recovery_time`` ниже, чем ``error_ratio``, то "
"следующее состояние будет установлено в **PASSING**, в противном случае "
"снова **BROKEN**."

#: ../../source/circuit_breaker.rst:101
msgid ""
"Argument ``exception_inspector`` is a function that is called whenever an"
" exception from the list of monitored exceptions occurs. When ``False`` "
"will be returned, this exception will be ignored."
msgstr ""
"Аргумент ``exception_inspector`` это функция, которая вызывается всякий "
"раз, когда происходит исключение из списка отслеживаемых исключений. Если"
" она возвращает ``False`` - исключение будет проигнорировано."

#: ../../source/circuit_breaker.rst:109
msgid "cutout"
msgstr "Декоратор ``cutout`` - \"рубильник\""

#: ../../source/circuit_breaker.rst:111
msgid "Decorator for ``CircuitBreaker`` which wrapping functions."
msgstr ""
"Декоратор оборачивающий функцию таким образом, что все вызовы проходят "
"через предохраннитель, а именно через экземпляр ``CircuitBreaker`` для "
"этой функции."
