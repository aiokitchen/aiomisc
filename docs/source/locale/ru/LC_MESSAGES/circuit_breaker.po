# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Dmitry Orlov
# This file is distributed under the same license as the aiomisc package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: aiomisc 11.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-11-01 00:23+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/circuit_breaker.rst:2
msgid "Circuit Breaker"
msgstr "Предохранитель"

#: ../../source/circuit_breaker.rst:4
msgid ""
"`Circuit breaker is a design pattern`_ used in software development. It "
"is used to detect failures and encapsulates the logic of preventing a "
"failure from constantly recurring, during maintenance, temporary external"
" system failure or unexpected system difficulties."
msgstr ""
"`Предохранитель - это шаблон проектирования`_, используемый при разработке "
"программного обеспечения. Он используется для обнаружения сбоев и "
"инкапсулирует логику предотвращения постоянного повторения сбоя во время "
"обслуживания, временного сбоя внешней системы или неожиданных системных проблем."

#: ../../source/circuit_breaker.rst:9
msgid ""
"The following example demonstrates the simple usage of the current "
"implementation of ``aiomisc.CircuitBreaker``. An instance of "
"``CircuitBreaker`` collecting function call statistics. That contains "
"counters mapping with successful and failed function calls. Function "
"calls must be wrapped by the `CircuitBreaker.call` the method in order to"
" gather it."
msgstr ""
"Следующий пример демонстрирует простое использование текущей реализации "
"``aiomisc.CircuitBreaker``. Экземпляр ``CircuitBreaker``, собирает "
"статистику вызовов функций. Он содержит счетчики которые содержат успешные "
"и неудачные вызовы функции. Вызовы функций должны быть обернуты методом "
"`CircuitBreaker.call`, чтобы собирать статистику."

#: ../../source/circuit_breaker.rst:16
msgid "Usage example:"
msgstr "Пример использования:"

#: ../../source/circuit_breaker.rst:65
msgid "The `CircuitBreaker` object might be one of three states:"
msgstr "Объект `CircuitBreaker` может находится в одном из трех состояний:"

#: ../../source/circuit_breaker.rst:67
msgid "**PASSING**"
msgstr "**PASSING** - аналогия с \"ток протекает\" (прим. пер.)"

#: ../../source/circuit_breaker.rst:68
msgid "**BROKEN**"
msgstr "**BROKEN** - аналогия со \"сгоревшим предохранителем\" (прим. пер.)"

#: ../../source/circuit_breaker.rst:69
msgid "**RECOVERING**"
msgstr "**RECOVERING** - восстанавливается"

#: ../../source/circuit_breaker.rst:73
msgid ""
"**PASSING** means all calls will be passed as is and statistics will be "
"gathered. Next state will be determined after collecting statistics for "
"``passing_time`` seconds. If an effective error ratio is greater than "
"`error_ratio` then the next state will be set to **BROKEN**, otherwise it"
" will remain unchanged."
msgstr ""
"**PASSING** означает, что все вызовы будут переданы как есть, но будет "
"собираться статистика. Следующее состояние будет определено после сбора "
"статистики за ``passing_time`` секунд. Если эффективный коэффициент "
"ошибок больше чем `error_ratio`, тогда следующее состояние будет установлено "
"как **BROKEN** (предохранитель перегорел, прим. пер.), в противном случае "
"оно останется неизменным."

#: ../../source/circuit_breaker.rst:79
msgid ""
"**BROKEN** means the wrapped function wont be called and "
"``CircuitBroken`` exception will be raised instead. **BROKEN** state will"
" be kept for ``broken_time`` seconds."
msgstr ""
"**BROKEN** означает, что обернутая функция не будет вызываться и вместо нее "
"будет брошено исключение ``CircuitBroken``. Состояние **BROKEN** будет "
"сохраняться в течение ``broken_time`` секунд."

#: ../../source/circuit_breaker.rst:85
msgid ""
"``CircuitBroken`` exception is a consequence of **BROKEN** or "
"**RECOVERY** state and never be accounted for in the statistic."
msgstr ""
"Исключение ``CircuitBroken`` является следствием состояния **BROKEN** или "
"**RECOVERY** и никогда не учитывается в статистике."

#: ../../source/circuit_breaker.rst:88
msgid ""
"After that, it changes to **RECOVERING** state. While in that state, "
"small sample of the wrapped function calls will actually be executed and "
"statistics will be gathered. If the effective error ratio after "
"``recovery_time`` is lower than ``error_ratio`` then the next state will "
"be set to **PASSING**, and otherwise - to **BROKEN**."
msgstr ""
"После этого предохранитель переходит в состояние **RECOVERING**. "
"В этом состоянии фактически будет выполняться небольшая выборка обернутых "
"вызовов функции, но будет собираться статистика. Если эффективный коэффициент "
"ошибок после ``recovery_time`` ниже, чем ``error_ratio``, то следующее "
"состояние будет установлено в **PASSING**, в противном случае снова **BROKEN**."

#: ../../source/circuit_breaker.rst:99
msgid "cutout"
msgstr "Декоратор ``cutout`` - \"рубильник\""

#: ../../source/circuit_breaker.rst:101
msgid "Decorator for ``CircuitBreaker`` which wrapping functions."
msgstr "Декоратор оборачивающий функцию таким образом, что все вызовы проходят "
"через предохраннитель, а именно через экземпляр ``CircuitBreaker`` "
"для этой функции."
