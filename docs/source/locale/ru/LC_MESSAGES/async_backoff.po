# Translations template for aiomisc.
# Copyright (C) 2021
# This file is distributed under the same license as the aiomisc project.
# Dmitry Orlov <me@mosquito.su>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: aiomisc 12.1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-29 11:36+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dmitry Orlov me@mosquito.su\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../source/async_backoff.rst:2
msgid "``@aiomisc.asyncbackoff``"
msgstr ""

#: ../../source/async_backoff.rst:4
msgid ""
"``asyncbackoff`` it's a decorator that helps you guarantee maximal async "
"function execution and retrying policy."
msgstr ""
"``asyncbackoff `` декоратор который обеспечивает политику повторов и "
"политику максимального количества повторных попыток выполнения "
"асинхронной функции."

#: ../../source/async_backoff.rst:7
msgid "The main principle might be described in five rules:"
msgstr "Основной принцип может быть описан пятью правилами:"

#: ../../source/async_backoff.rst:9
msgid ""
"function will be canceled when executed longer than ``deadline`` (if "
"specified)"
msgstr ""
"функция будет отменена, если она будет выполнена дольше, чем ``deadline``"
" (если указано)"

#: ../../source/async_backoff.rst:11
msgid ""
"function will be canceled when executed longer than ``attempt_timeout`` "
"(if specified) and will be retried"
msgstr ""
"функция будет отменена при выполнении дольше, чем ``attempt_timeout` "
"(если указано) после этого будет выполнена повторная попытка."

#: ../../source/async_backoff.rst:13
msgid ""
"Reattempts performs after ``pause`` seconds (if specified, default is "
"``0``)"
msgstr ""
"Попытки выполняются после ``pause`` секунд (если указано, по умолчанию "
"``0``)"

#: ../../source/async_backoff.rst:14
msgid "Reattempts will be performed not more than ``max_tries`` times."
msgstr "Попытки будут выполняться не более ``max_tries`` раз."

#: ../../source/async_backoff.rst:15
msgid ""
"``giveup`` argument is a function that decides should give up the "
"reattempts or continue retrying."
msgstr ""
"аргумент ``giveup`` - это функция, которая решает, следует ли \"сдаться\""
" и прекратить дальнейшие попыток или продолжать."

#: ../../source/async_backoff.rst:18
msgid "All these rules work at the same time."
msgstr "Все эти правила работают одновременно."

#: ../../source/async_backoff.rst:20
msgid "Arguments description:"
msgstr "Описание аргументов:"

#: ../../source/async_backoff.rst:22
msgid "``attempt_timeout`` is maximum execution time for one execution attempt."
msgstr "``attempt_timeout`` максимально допустимое время выполнения одной попытки."

#: ../../source/async_backoff.rst:23
msgid "``deadline`` is maximum execution time for all execution attempts."
msgstr "``deadline`` максимально допустимое время выполнения всех попыток."

#: ../../source/async_backoff.rst:24
msgid "``pause`` is the time gap between execution attempts."
msgstr "``pause`` промежуток времени между попытками."

#: ../../source/async_backoff.rst:25
msgid "``exceptions`` retrying when these exceptions were raised."
msgstr ""
"``exceptions`` делает последующие попытки только если эти будут брошены "
"эти исключения."

#: ../../source/async_backoff.rst:26
msgid ""
"``giveup`` (keyword only) is a predicate function that can decide by a "
"given exception if we should continue to do retries."
msgstr ""
"``giveup`` (именовынный аргумент) это функция-предикат, которая может "
"решить по данному исключению, следует ли нам продолжать повторять "
"попытки."

#: ../../source/async_backoff.rst:27
msgid ""
"``max_tries`` (keyword only) is maximum count of execution attempts (>= "
"1)."
msgstr ""
"``max_tries`` (именовынный аргумент) - максимальное количество попыток (>"
" = 1)."

#: ../../source/async_backoff.rst:29
msgid ""
"Decorator that ensures that ``attempt_timeout`` and ``deadline`` time "
"limits are met by decorated function."
msgstr ""
"Декоратор, обеспечивающий соблюдение временных ограничений "
"\"attempt_timeout\" и \"deadline\" декорированной функцией."

#: ../../source/async_backoff.rst:32
msgid ""
"In case of exception, the function will be called again with similar "
"arguments after ``pause`` seconds."
msgstr ""
"В случае возникновения исключения функция будет вызвана снова с "
"аналогичными аргументами через кол-во секунд переданное в аргументе "
"\"pause\"."

#: ../../source/async_backoff.rst:36
msgid "Position arguments notation:"
msgstr "Объявление через позиционные аргументы:"

#: ../../source/async_backoff.rst:38
msgid ""
"import aiomisc\n"
"\n"
"attempt_timeout = 0.1\n"
"deadline = 1\n"
"pause = 0.1\n"
"\n"
"@aiomisc.asyncbackoff(attempt_timeout, deadline, pause)\n"
"async def db_fetch():\n"
"    ...\n"
"\n"
"\n"
"@aiomisc.asyncbackoff(0.1, 1, 0.1)\n"
"async def db_save(data: dict):\n"
"    ...\n"
"\n"
"\n"
"# Passing exceptions for handling\n"
"@aiomisc.asyncbackoff(0.1, 1, 0.1, TypeError, RuntimeError, ValueError)\n"
"async def db_fetch(data: dict):\n"
"    ..."
msgstr ""
"import aiomisc\n"
"\n"
"attempt_timeout = 0.1\n"
"deadline = 1\n"
"pause = 0.1\n"
"\n"
"@aiomisc.asyncbackoff(attempt_timeout, deadline, pause)\n"
"async def db_fetch():\n"
"    ...\n"
"\n"
"\n"
"@aiomisc.asyncbackoff(0.1, 1, 0.1)\n"
"async def db_save(data: dict):\n"
"    ...\n"
"\n"
"\n"
"# Передаем список исключений\n"
"@aiomisc.asyncbackoff(0.1, 1, 0.1, TypeError, RuntimeError, ValueError)\n"
"async def db_fetch(data: dict):\n"
"    ..."

#: ../../source/async_backoff.rst:62
msgid "Keyword arguments notation:"
msgstr "Объявление через именованные аргументы"

#: ../../source/async_backoff.rst:64
msgid ""
"import aiomisc\n"
"\n"
"attempt_timeout = 0.1\n"
"deadline = 1\n"
"pause = 0.1\n"
"\n"
"@aiomisc.asyncbackoff(attempt_timeout=attempt_timeout,\n"
"                      deadline=deadline, pause=pause)\n"
"async def db_fetch():\n"
"    ...\n"
"\n"
"\n"
"@aiomisc.asyncbackoff(attempt_timeout=0.1, deadline=1, pause=0.1)\n"
"async def db_save(data: dict):\n"
"    ...\n"
"\n"
"\n"
"# Passing exceptions for handling\n"
"@aiomisc.asyncbackoff(attempt_timeout=0.1, deadline=1, pause=0.1,\n"
"                      exceptions=[TypeError, RuntimeError, ValueError])\n"
"async def db_fetch(data: dict):\n"
"    ...\n"
"\n"
"\n"
"# Will be retried no more than 2 times (3 tries total)\n"
"@aiomisc.asyncbackoff(attempt_timeout=0.5, deadline=1,\n"
"                      pause=0.1, max_tries=3,\n"
"                      exceptions=[TypeError, RuntimeError, ValueError])\n"
"async def db_fetch(data: dict):\n"
"    ...\n"
"\n"
"\n"
"# Will be retried only on connection abort (on POSIX systems)\n"
"@asyncbackoff(attempt_timeout=0.5, deadline=1, pause=0.1,\n"
"              exceptions=[OSError],\n"
"              giveup=lambda e: e.errno != errno.ECONNABORTED)\n"
"async def db_fetch(data: dict):\n"
"    ..."
msgstr ""
"import aiomisc\n"
"\n"
"attempt_timeout = 0.1\n"
"deadline = 1\n"
"pause = 0.1\n"
"\n"
"@aiomisc.asyncbackoff(attempt_timeout=attempt_timeout,\n"
"                      deadline=deadline, pause=pause)\n"
"async def db_fetch():\n"
"    ...\n"
"\n"
"\n"
"@aiomisc.asyncbackoff(attempt_timeout=0.1, deadline=1, pause=0.1)\n"
"async def db_save(data: dict):\n"
"    ...\n"
"\n"
"\n"
"# Передаем список исключений\n"
"@aiomisc.asyncbackoff(attempt_timeout=0.1, deadline=1, pause=0.1,\n"
"                      exceptions=[TypeError, RuntimeError, ValueError])\n"
"async def db_fetch(data: dict):\n"
"    ...\n"
"\n"
"\n"
"# Будет повторено не больше чем 2 раза (всего 3 попытки)\n"
"@aiomisc.asyncbackoff(attempt_timeout=0.5, deadline=1,\n"
"                      pause=0.1, max_tries=3,\n"
"                      exceptions=[TypeError, RuntimeError, ValueError])\n"
"async def db_fetch(data: dict):\n"
"    ...\n"
"\n"
"\n"
"# Повторы будут только если соединение было сброшено (только POSIX системы)\n"
"@asyncbackoff(attempt_timeout=0.5, deadline=1, pause=0.1,\n"
"              exceptions=[OSError],\n"
"              giveup=lambda e: e.errno != errno.ECONNABORTED)\n"
"async def db_fetch(data: dict):\n"
"    ..."

#: ../../source/async_backoff.rst:109
msgid "``asyncretry``"
msgstr ""

#: ../../source/async_backoff.rst:111
msgid ""
"Shortcut of ``asyncbackoff(None, None, 0, *args, **kwargs)``. Just "
"retries ``max_tries`` times."
msgstr ""
"Аналог ``asyncbackoff(None, None, 0, *args, **kwargs)``. Прсто повторяет "
"выполнение функции ``max_tries`` раз."

#: ../../source/async_backoff.rst:116
msgid ""
"By default will be retry when any Exception. It's very simple and useful "
"in generic cases, but you should specify an exception list when you're "
"wrapped functions calling hundreds of times per second, cause you have a "
"risk be the reason for denial of service in case your function calls "
"remote service."
msgstr ""
"По умолчанию будет повторена попытка при любом исключении. Это очень "
"просто и полезно в общих случаях, при этом следует указать список "
"исключений тогда, когда обернутые функции вызывают сотни раз в секунду, "
"потому что у вас есть риск быть причиной отказа в обслуживании в случае, "
"если ваша функция вызывает какой-то сервис по сети."

#: ../../source/async_backoff.rst:121
msgid ""
"from aiomisc import asyncretry\n"
"\n"
"@asyncretry(5)\n"
"async def try_download_file(url):\n"
"    ...\n"
"\n"
"@asyncretry(3, exceptions=(ConnectionError,))\n"
"async def get_cluster_lock():\n"
"    ..."
msgstr ""
