# Translations template for aiomisc.
# Copyright (C) 2021
# This file is distributed under the same license as the aiomisc project.
# Dmitry Orlov <me@mosquito.su>, 2022.
msgid ""
msgstr ""
"Project-Id-Version:  14\n"
"Report-Msgid-Bugs-To: me@mosquito.su\n"
"POT-Creation-Date: 2022-12-29 11:36+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dmitry Orlov <me@mosquito.su>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../source/pytest.rst:2
msgid "Pytest plugin"
msgstr "Плагин для Pytest"

#: ../../source/pytest.rst:4
msgid "This package contains a plugin for pytest."
msgstr "Этот пакет содержит plugin для pytest."

#: ../../source/pytest.rst:7
msgid "Basic usage"
msgstr "Простой пример"

#: ../../source/pytest.rst:9
msgid "Simple usage example:"
msgstr "Простой пример использования:"

#: ../../source/pytest.rst:11
msgid ""
"import asyncio\n"
"import pytest\n"
"\n"
"\n"
"async def test_sample(loop):\n"
"    f = loop.crete_future()\n"
"    loop.call_soon(f.set_result, True)\n"
"\n"
"    assert await f"
msgstr ""

#: ../../source/pytest.rst:24
msgid "asynchronous fixture example:"
msgstr "пример асинхронной фикстуры:"

#: ../../source/pytest.rst:27
msgid ""
"import asyncio\n"
"import pytest\n"
"\n"
"\n"
"@pytest.fixture\n"
"async def my_fixture(loop):\n"
"    await asyncio.sleep(0)\n"
"\n"
"    # Requires python 3.6+\n"
"    yield"
msgstr ""

#: ../../source/pytest.rst:40
msgid ""
"In case you have to save an instance of an async fixture between tests, "
"the wrong solution is just changing the fixture scope. But why it "
"wouldn't work? That's because, in the base scenario, the ``loop`` fixture"
" creates a new event loop instance per test which will be closed after "
"test teardown. When you have to use an async fixture any caller of "
"``asyncio.get_event_loop()`` will get the current event loop instance "
"which will be closed and the next test will run in another event loop. So"
" the solution is to redefine the ``loop`` fixture with the required scope"
" and custom fixture with the required scope."
msgstr ""
"В случае, если вам необходимо сохранить экземпляр асинхронной фиксуры "
"между тестами, неправильным решением будет просто изменить scope "
"фикстуры.Но почему это не сработает? Это связано с тем, что в базовом "
"сценарии фикстура ``loop`` создает новый экземпляр event-loop для каждого"
" теста, и он будет закрыт по завершении теста. Когда нужно использовать "
"асинхронную фикстуру, любой вызов ``asyncio.get_event_loop()`` вернет "
"текущий экземпляр event-loop, который будет закрыт, и следующий тест "
"будет выполняться в другом экземпляре event-loop.Таким образом, решение "
"заключается в переопределении фикстуры ``loop`` с требуемым scope и "
"пользовательской фиктуры."

#: ../../source/pytest.rst:50
msgid ""
"import asyncio\n"
"import pytest\n"
"from aiomisc import entrypoint\n"
"\n"
"\n"
"@pytest.fixture(scope='module')\n"
"def loop():\n"
"    with entrypoint() as loop:\n"
"        asyncio.set_event_loop(loop)\n"
"        yield loop\n"
"\n"
"\n"
"@pytest.fixture(scope='module')\n"
"async def sample_fixture(loop):\n"
"    yield 1\n"
"\n"
"\n"
"LOOP_ID = None\n"
"\n"
"\n"
"async def test_using_fixture(sample_fixture):\n"
"    global LOOP_ID\n"
"    LOOP_ID = id(asyncio.get_event_loop())\n"
"    assert sample_fixture == 1\n"
"\n"
"\n"
"async def test_not_using_fixture(loop):\n"
"    assert id(loop) == LOOP_ID"
msgstr ""

#: ../../source/pytest.rst:83
msgid "pytest markers"
msgstr "маркеры pytest"

#: ../../source/pytest.rst:85
msgid "Package contains some useful markers for pytest:"
msgstr "Пакет содержит несколько полезных маркеров для pytest:"

#: ../../source/pytest.rst:87
msgid ""
"``catch_loop_exceptions`` - uncaught event loop exceptions will failling "
"test."
msgstr ""
"``catch_loop_exceptions`` - непойманные исклбчения в event loop сломают "
"тест."

#: ../../source/pytest.rst:88
msgid ""
"``forbid_get_event_loop`` - forbids call ``asyncio.get_event_loop`` "
"during test case."
msgstr ""
"``forbid_get_event_loop`` - запрещает вызов ``asyncio.get_event_loop`` "
"при прогоне теста."

#: ../../source/pytest.rst:91
msgid ""
"import pytest\n"
"\n"
"\n"
"# Test will be failed\n"
"@pytest.mark.forbid_get_event_loop\n"
"async def test_with_get_loop():\n"
"    def switch_context():\n"
"        loop = get_event_loop()\n"
"        future = loop.create_future()\n"
"        loop.call_soon(future.set_result, True)\n"
"        return future\n"
"\n"
"    with pytest.raises(Failed):\n"
"        await switch_context()\n"
"\n"
"\n"
"# Test will be failed\n"
"@pytest.mark.catch_loop_exceptions\n"
"async def test_with_errors(loop):\n"
"    async def fail():\n"
"        # switch context\n"
"        await asyncio.sleep(0)\n"
"        raise Exception()\n"
"\n"
"    loop.create_task(fail())\n"
"    await asyncio.sleep(0.1)\n"
"    return"
msgstr ""
"import pytest\n"
"\n"
"\n"
"# Тест упадет\n"
"@pytest.mark.forbid_get_event_loop\n"
"async def test_with_get_loop():\n"
"    def switch_context():\n"
"        loop = get_event_loop()\n"
"        future = loop.create_future()\n"
"        loop.call_soon(future.set_result, True)\n"
"        return future\n"
"\n"
"    with pytest.raises(Failed):\n"
"        await switch_context()\n"
"\n"
"\n"
"# Тест упадет\n"
"@pytest.mark.catch_loop_exceptions\n"
"async def test_with_errors(loop):\n"
"    async def fail():\n"
"        # переключаем контекст\n"
"        await asyncio.sleep(0)\n"
"        raise Exception()\n"
"\n"
"    loop.create_task(fail())\n"
"    await asyncio.sleep(0.1)\n"
"    return"

#: ../../source/pytest.rst:123
msgid "Passing default context"
msgstr "Передача контекста по умолчанию"

#: ../../source/pytest.rst:125
msgid ""
"import pytest\n"
"\n"
"\n"
"@pytest.fixture\n"
"def default_context():\n"
"    return {\n"
"        'foo': 'bar',\n"
"        'bar': 'foo',\n"
"    }"
msgstr ""

#: ../../source/pytest.rst:139
msgid "Testing services"
msgstr "Тестирование сервисов"

#: ../../source/pytest.rst:141
msgid "Redefine ``services`` fixture in your test module:"
msgstr "Переопределите фикстуру ``services`` в вашем тестовом модуле:"

#: ../../source/pytest.rst:143
msgid ""
"@pytest.fixture\n"
"def services(aiomisc_unused_port, handlers):\n"
"    return [\n"
"        RPCServer(\n"
"            handlers={'foo': lambda: 'bar'},\n"
"            address='localhost',\n"
"            port=aiomisc_unused_port\n"
"        )\n"
"    ]"
msgstr ""

#: ../../source/pytest.rst:157
msgid "Event loop policy overriding"
msgstr "Переопределение политики создания цикла событий"

#: ../../source/pytest.rst:159
msgid ""
"import uvloop\n"
"import tokio\n"
"\n"
"policy_ids = ('uvloop', 'asyncio', 'tokio')\n"
"policies = (uvloop.EventLoopPolicy(),\n"
"            asyncio.DefaultEventLoopPolicy(),\n"
"            tokio.EventLoopPolicy())\n"
"\n"
"@pytest.fixture(params=policies, ids=policy_ids)\n"
"def event_loop_policy(request):\n"
"    return request.param"
msgstr ""

#: ../../source/pytest.rst:175
msgid "Thread pool overriding"
msgstr "Переопределение пула потоков"

#: ../../source/pytest.rst:177
msgid ""
"thread_pool_ids = ('aiomisc pool', 'default pool')\n"
"thread_pool_implementation = (ThreadPoolExecutor,\n"
"                              concurrent.futures.ThreadPoolExecutor)\n"
"\n"
"\n"
"@pytest.fixture(params=thread_pool_implementation, ids=thread_pool_ids)\n"
"def thread_pool_executor(request):\n"
"    return request.param"
msgstr ""

#: ../../source/pytest.rst:190
msgid "entrypoint arguments"
msgstr "агрументы entrypoint"

#: ../../source/pytest.rst:192
msgid ""
"import pytest\n"
"\n"
"@pytest.fixture\n"
"def entrypoint_kwargs() -> dict:\n"
"    return dict(log_config=False)"
msgstr ""

#: ../../source/pytest.rst:202
msgid "aiohttp test client"
msgstr "тестовый класс для aiohttp"

#: ../../source/pytest.rst:204
msgid ""
"import pytest\n"
"from myapp.services.rest import REST\n"
"\n"
"\n"
"@pytest.fixture\n"
"def rest_port(aiomisc_unused_port_factory):\n"
"    return aiomisc_unused_port_factory()\n"
"\n"
"\n"
"@pytest.fixture\n"
"def rest_service(rest_port):\n"
"    return REST(port=rest_port)\n"
"\n"
"\n"
"@pytest.fixture\n"
"def services(rest_service):\n"
"    return [rest_service]\n"
"\n"
"\n"
"@pytest.fixture\n"
"def api_client(api_service):\n"
"    test_srv = TestServer(\n"
"        app=rest_service.app,\n"
"        port=arguments.port,\n"
"    )\n"
"\n"
"    return TestClient(test_srv)\n"
"\n"
"..."
msgstr ""

#: ../../source/pytest.rst:238
msgid "TCPProxy"
msgstr "TCPProxy"

#: ../../source/pytest.rst:240
msgid ""
"Simple TCP proxy for emulate network problems. Available as fixture "
"`tcp_proxy`"
msgstr ""
"Простой TCP proxy для эмуляции сетевых проблем. Доступен как фикстура "
"`tcp_proxy`"

#: ../../source/pytest.rst:243
msgid "Examples:"
msgstr "Примеры:"

#: ../../source/pytest.rst:245
msgid ""
"import asyncio\n"
"import time\n"
"\n"
"import pytest\n"
"\n"
"import aiomisc\n"
"\n"
"\n"
"class EchoServer(aiomisc.service.TCPServer):\n"
"    async def handle_client(\n"
"            self, reader: asyncio.StreamReader,\n"
"            writer: asyncio.StreamWriter\n"
"    ):\n"
"        chunk = await reader.read(65534)\n"
"        while chunk:\n"
"            writer.write(chunk)\n"
"            chunk = await reader.read(65534)\n"
"\n"
"        writer.close()\n"
"        await writer.wait_closed()\n"
"\n"
"\n"
"@pytest.fixture()\n"
"def server_port(aiomisc_unused_port_factory) -> int:\n"
"    return aiomisc_unused_port_factory()\n"
"\n"
"\n"
"@pytest.fixture()\n"
"def services(server_port, localhost):\n"
"    return [EchoServer(port=server_port, address=localhost)]\n"
"\n"
"\n"
"@pytest.fixture()\n"
"async def proxy(tcp_proxy, localhost, server_port):\n"
"    async with tcp_proxy(localhost, server_port) as proxy:\n"
"        yield proxy\n"
"\n"
"\n"
"async def test_proxy_client_close(proxy):\n"
"    reader, writer = await proxy.create_client()\n"
"    payload = b\"Hello world\"\n"
"\n"
"    writer.write(payload)\n"
"    response = await asyncio.wait_for(reader.read(1024), timeout=1)\n"
"\n"
"    assert response == payload\n"
"\n"
"    assert not reader.at_eof()\n"
"    await proxy.disconnect_all()\n"
"\n"
"    assert await asyncio.wait_for(reader.read(), timeout=1) == b\"\"\n"
"    assert reader.at_eof()\n"
"\n"
"\n"
"async def test_proxy_client_slow(proxy):\n"
"    read_delay = 0.1\n"
"    write_delay = 0.2\n"
"\n"
"    # Emulation of asymmetric and slow ISP\n"
"    with proxy.slowdown(read_delay, write_delay):\n"
"        reader, writer = await proxy.create_client()\n"
"        payload = b\"Hello world\"\n"
"\n"
"        delta = -time.monotonic()\n"
"\n"
"        writer.write(payload)\n"
"        await asyncio.wait_for(reader.read(1024), timeout=2)\n"
"\n"
"        delta += time.monotonic()\n"
"\n"
"        assert delta >= read_delay + write_delay\n"
"\n"
"\n"
"async def test_proxy_client_with_processor(proxy):\n"
"    processed_request = b\"Never say hello\"\n"
"\n"
"    # Patching protocol functions\n"
"    proxy.set_content_processors(\n"
"        # Process data from client to server\n"
"        lambda _: processed_request,\n"
"\n"
"        # Process data from server to client\n"
"        lambda chunk: chunk[::-1],\n"
"    )\n"
"\n"
"    reader, writer = await proxy.create_client()\n"
"    writer.write(b'nevermind')\n"
"\n"
"    response = await reader.read(16)\n"
"\n"
"    assert response == processed_request[::-1]"
msgstr ""
"import asyncio\n"
"import time\n"
"\n"
"import pytest\n"
"\n"
"import aiomisc\n"
"\n"
"\n"
"class EchoServer(aiomisc.service.TCPServer):\n"
"    async def handle_client(\n"
"            self, reader: asyncio.StreamReader,\n"
"            writer: asyncio.StreamWriter\n"
"    ):\n"
"        chunk = await reader.read(65534)\n"
"        while chunk:\n"
"            writer.write(chunk)\n"
"            chunk = await reader.read(65534)\n"
"\n"
"        writer.close()\n"
"        await writer.wait_closed()\n"
"\n"
"\n"
"@pytest.fixture()\n"
"def server_port(aiomisc_unused_port_factory) -> int:\n"
"    return aiomisc_unused_port_factory()\n"
"\n"
"\n"
"@pytest.fixture()\n"
"def services(server_port, localhost):\n"
"    return [EchoServer(port=server_port, address=localhost)]\n"
"\n"
"\n"
"@pytest.fixture()\n"
"async def proxy(tcp_proxy, localhost, server_port):\n"
"    async with tcp_proxy(localhost, server_port) as proxy:\n"
"        yield proxy\n"
"\n"
"\n"
"async def test_proxy_client_close(proxy):\n"
"    reader, writer = await proxy.create_client()\n"
"    payload = b\"Hello world\"\n"
"\n"
"    writer.write(payload)\n"
"    response = await asyncio.wait_for(reader.read(1024), timeout=1)\n"
"\n"
"    assert response == payload\n"
"\n"
"    assert not reader.at_eof()\n"
"    await proxy.disconnect_all()\n"
"\n"
"    assert await asyncio.wait_for(reader.read(), timeout=1) == b\"\"\n"
"    assert reader.at_eof()\n"
"\n"
"\n"
"async def test_proxy_client_slow(proxy):\n"
"    read_delay = 0.1\n"
"    write_delay = 0.2\n"
"\n"
"    # Эмулируем работу ассиметричного и медленного интернет провайдера\n"
"    with proxy.slowdown(read_delay, write_delay):\n"
"        reader, writer = await proxy.create_client()\n"
"        payload = b\"Hello world\"\n"
"\n"
"        delta = -time.monotonic()\n"
"\n"
"        writer.write(payload)\n"
"        await asyncio.wait_for(reader.read(1024), timeout=2)\n"
"\n"
"        delta += time.monotonic()\n"
"\n"
"        assert delta >= read_delay + write_delay\n"
"\n"
"\n"
"async def test_proxy_client_with_processor(proxy):\n"
"    processed_request = b\"Never say hello\"\n"
"\n"
"    # Патчим функции протокола\n"
"    proxy.set_content_processors(\n"
"        # Тут обработаем данные от клиента к серверу\n"
"        lambda _: processed_request,\n"
"\n"
"        # Тут обработаем данные от сервера к клиенту\n"
"        lambda chunk: chunk[::-1],\n"
"    )\n"
"\n"
"    reader, writer = await proxy.create_client()\n"
"    writer.write(b'nevermind')\n"
"\n"
"    response = await reader.read(16)\n"
"\n"
"    assert response == processed_request[::-1]"
