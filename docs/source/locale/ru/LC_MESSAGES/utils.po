# Translations template for aiomisc.
# Copyright (C) 2021
# This file is distributed under the same license as the aiomisc project.
# Dmitry Orlov <me@mosquito.su>, 2022.
msgid ""
msgstr ""
"Project-Id-Version:  14\n"
"Report-Msgid-Bugs-To: me@mosquito.su\n"
"POT-Creation-Date: 2022-12-29 11:36+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dmitry Orlov <me@mosquito.su>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../source/utils.rst:2
msgid "Utilities"
msgstr "Утилиты"

#: ../../source/utils.rst:5
msgid "``select``"
msgstr ""

#: ../../source/utils.rst:7
msgid ""
"In some cases, you should wait for only one of multiple tasks. ``select``"
" waits first passed awaitable object and returns the list of results."
msgstr ""
"Иногда требуется дождаться выполнения хотя-бы одной задачи из многих. "
"``select`` ожидает выполнения одной из переданных сопрограмм (или "
"объектов с реализованным методом `__await__`) И возвращает список "
"результатов."

#: ../../source/utils.rst:10
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_event_loop()\n"
"    event = asyncio.Event()\n"
"    future = asyncio.Future()\n"
"\n"
"    loop.call_soon(event.set)\n"
"\n"
"    await aiomisc.select(event.wait(), future)\n"
"    print(event.is_set())       # True\n"
"\n"
"    event = asyncio.Event()\n"
"    future = asyncio.Future()\n"
"\n"
"    loop.call_soon(future.set_result, True)\n"
"\n"
"    results = await aiomisc.select(future, event.wait())\n"
"    future_result, event_result = results\n"
"\n"
"    print(results.result())             # True\n"
"    print(results.result_idx)           # 0\n"
"    print(event_result, future_result)  # None, True\n"
"\n"
"\n"
"with aiomisc.entrypoint() as loop:\n"
"    loop.run_until_complete(main())"
msgstr ""

#: ../../source/utils.rst:45
msgid ""
"When you don't want to cancel pending tasks pass ``cancel=False`` "
"argument. In this case, you have to handle task completion manually or "
"get warnings."
msgstr ""
"В случае если вы не желаете отменять запущенные задачии передайте "
"аргумент ``cancel=False``. Но в этом случае вам придется разобраться с "
"завершением или отменой самостоятельон иначе будет предупреждение от "
"интерпретатора."

#: ../../source/utils.rst:50
msgid "``cancel_tasks``"
msgstr ""

#: ../../source/utils.rst:52
msgid "All passed tasks will be canceled and the task will be returned:"
msgstr ""
"Все переданные задачи будут отменены, при это функция возвращает "
"`asyncio.Task`:"

#: ../../source/utils.rst:54
msgid ""
"import asyncio\n"
"from aiomisc import cancel_tasks\n"
"\n"
"\n"
"async def main():\n"
"    done, pending = await asyncio.wait([\n"
"        asyncio.sleep(i) for i in range(10)\n"
"    ], timeout=5)\n"
"\n"
"    print(\"Done\", len(done), \"tasks\")\n"
"    print(\"Pending\", len(pending), \"tasks\")\n"
"    await cancel_tasks(pending)\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""

#: ../../source/utils.rst:74
msgid "``awaitable``"
msgstr ""

#: ../../source/utils.rst:76
msgid ""
"Decorator wraps function and returns a function that returns awaitable "
"object. In case a function returns a future, the original future will be "
"returned. In case then the function returns a coroutine, the original "
"coroutine will be returned. In case than function returns a non-awaitable"
" object, it's will be wrapped to a new coroutine that just returns this "
"object. It's useful when you don't want to check function results before "
"use it in ``await`` expression."
msgstr ""
"Оборачивает функции таким образом что они всегда возвращают сопрограмму. "
"Если функция возвращает объект `asyncio.Future`, будет возвращен "
"оригинальный объект. Если функция итак возвращает сопрограмму, или объект"
" с реализованным методом `__await__` будет возвращен оригинальный "
"объект.В противном случае возвращаемый объект будет тобернут в "
"сопрограмму, которая вернет этот объект.Это полезно если не хочется "
"проверять возврат из функции перед тем как использовать ее в `await` "
"выражении."

#: ../../source/utils.rst:84
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"async def do_callback(func, *args):\n"
"    awaitable_func = aiomisc.awaitable(func)\n"
"\n"
"    return await awaitable_func(*args)\n"
"\n"
"\n"
"print(asyncio.run(do_callback(asyncio.sleep, 2)))\n"
"print(asyncio.run(do_callback(lambda: 45)))"
msgstr ""

#: ../../source/utils.rst:100
msgid "``bind_socket``"
msgstr ""

#: ../../source/utils.rst:102
msgid ""
"Bind socket and set ``setblocking(False)`` for just created socket. This "
"detects ``address`` format and selects the socket family automatically."
msgstr ""
"Создает сокет и устанавливает для него необходимые для работы с asyncio "
"флаги (вроде ``setblocking(False)``). Так-же определяет семейство адресов"
" (IPv6/IPv4) из формата аргумента ``address`` автоматически."

#: ../../source/utils.rst:105
msgid ""
"from aiomisc import bind_socket\n"
"\n"
"# IPv4 socket\n"
"sock = bind_socket(address=\"127.0.0.1\", port=1234)\n"
"\n"
"# IPv6 socket (on Linux IPv4 socket will be bind too)\n"
"sock = bind_socket(address=\"::1\", port=1234)"
msgstr ""

#: ../../source/utils.rst:117
msgid "``RecurringCallback``"
msgstr ""

#: ../../source/utils.rst:119
msgid "Runs coroutine function periodically with user-defined strategy."
msgstr ""
"Запускает сопрограммы переодически с определяемой пользователем "
"стратегией."

#: ../../source/utils.rst:121
msgid ""
"from typing import Union\n"
"from aiomisc import new_event_loop, RecurringCallback\n"
"\n"
"\n"
"async def callback():\n"
"    print(\"Hello\")\n"
"\n"
"\n"
"FIRST_CALL = False\n"
"\n"
"\n"
"async def strategy(_: RecurringCallback) -> Union[int, float]:\n"
"    global FIRST_CALL\n"
"    if not FIRST_CALL:\n"
"        FIRST_CALL = True\n"
"        # Delay 5 second if just started\n"
"        return 5\n"
"\n"
"    # Delay 10 seconds if it is not a first call\n"
"    return 10\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    loop = new_event_loop()\n"
"\n"
"    periodic = RecurringCallback(callback)\n"
"\n"
"    task = periodic.start(strategy)\n"
"    loop.run_forever()"
msgstr ""
"from typing import Union\n"
"from aiomisc import new_event_loop, RecurringCallback\n"
"\n"
"\n"
"async def callback():\n"
"    print(\"Hello\")\n"
"\n"
"\n"
"FIRST_CALL = False\n"
"\n"
"\n"
"async def strategy(_: RecurringCallback) -> Union[int, float]:\n"
"    global FIRST_CALL\n"
"    if not FIRST_CALL:\n"
"        FIRST_CALL = True\n"
"        # Ждем 5 секунд если только-что запустились\n"
"        return 5\n"
"\n"
"    # Ждем 10 секунд если это не первый запуск\n"
"    return 10\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    loop = new_event_loop()\n"
"\n"
"    periodic = RecurringCallback(callback)\n"
"\n"
"    task = periodic.start(strategy)\n"
"    loop.run_forever()"

#: ../../source/utils.rst:154
msgid ""
"The main purpose is this class is to provide ability to specify the "
"asynchronous strategy function, which can be written very flexible."
msgstr ""
"Основная цель этого класса - предоставить возможность указывать "
"стратегией асинхронную функцию, которая может быть так как вам нужно."

#: ../../source/utils.rst:157
msgid ""
"Also, with the special exceptions, you can control the behavior of the "
"started ``RecurringCallback``."
msgstr ""
"Кроме того, с помощью специальных исключений вы можете управлять "
"поведением запущенного ``RecurringCallback``."

#: ../../source/utils.rst:160
msgid ""
"from aiomisc import (\n"
"    new_event_loop, RecurringCallback, StrategySkip, StrategyStop\n"
")\n"
"\n"
"\n"
"async def strategy(_: RecurringCallback) -> Union[int, float]:\n"
"    ...\n"
"\n"
"    # Skip this attempt and wait 10 seconds\n"
"    raise StrategySkip(10)\n"
"\n"
"    ...\n"
"\n"
"    # Stop execution\n"
"    raise StrategyStop()"
msgstr ""
"from aiomisc import (\n"
"    new_event_loop, RecurringCallback, StrategySkip, StrategyStop\n"
")\n"
"\n"
"\n"
"async def strategy(_: RecurringCallback) -> Union[int, float]:\n"
"    ...\n"
"\n"
"    # Пропускаем эту попытку и ждем 10 секунд\n"
"    raise StrategySkip(10)\n"
"\n"
"    ...\n"
"\n"
"    # Stop execution\n"
"    raise StrategyStop()"

#: ../../source/utils.rst:178
msgid ""
"if the strategy function returns an incorrect value (not a number), or "
"does not raise special exceptions, the recurring execution is terminated."
msgstr ""
"если функция-стратегия возвращает неверное значение (не число) или не "
"вызывает специальных исключений, повторяющееся выполнение завершается."

#: ../../source/utils.rst:183
msgid "``PeriodicCallback``"
msgstr ""

#: ../../source/utils.rst:185
msgid ""
"Runs coroutine function periodically with an optional delay of the first "
"execution. Uses ``RecurringCallback`` under the hood."
msgstr ""
"Запускает сопрограммы переодически с заданным периодом времени, и "
"необязательной задержкой при первом запуске. Использует "
"``RecurringCallback`` под капотом."

#: ../../source/utils.rst:188
msgid ""
"import asyncio\n"
"import time\n"
"from aiomisc import new_event_loop, PeriodicCallback\n"
"\n"
"\n"
"async def periodic_function():\n"
"    print(\"Hello\")\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    loop = new_event_loop()\n"
"\n"
"    periodic = PeriodicCallback(periodic_function)\n"
"\n"
"    # Wait 10 seconds and call it each second after that\n"
"    periodic.start(1, delay=10)\n"
"\n"
"    loop.run_forever()"
msgstr ""
"import asyncio\n"
"import time\n"
"from aiomisc import new_event_loop, PeriodicCallback\n"
"\n"
"\n"
"async def periodic_function():\n"
"    print(\"Hello\")\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    loop = new_event_loop()\n"
"\n"
"    periodic = PeriodicCallback(periodic_function)\n"
"\n"
"    # Ждем 10 секунд и вызываем это каждую секунду после этого\n"
"    periodic.start(1, delay=10)\n"
"\n"
"    loop.run_forever()"

#: ../../source/utils.rst:211
msgid "``CronCallback``"
msgstr ""

#: ../../source/utils.rst:215
msgid "You have to install ``croniter`` package for use this feature:"
msgstr "Придется установить пакет ``croniter`` чтобы пользоваться этим:"

#: ../../source/utils.rst:217
msgid "pip install croniter"
msgstr ""

#: ../../source/utils.rst:221
msgid "Or add extras when installing aiomisc:"
msgstr "Или указать это как extras при установке aiomisc:"

#: ../../source/utils.rst:223
msgid "pip install aiomisc[cron]"
msgstr ""

#: ../../source/utils.rst:229
msgid ""
"Runs coroutine function with cron scheduling execution. Uses "
"``RecurringCallback`` under the hood."
msgstr ""
"Запускает сопрограммы переодически, как-будто с помощью cron.Использует "
"``RecurringCallback`` под капотом."

#: ../../source/utils.rst:232
msgid ""
"import asyncio\n"
"import time\n"
"from aiomisc import new_event_loop, CronCallback\n"
"\n"
"\n"
"async def cron_function():\n"
"    print(\"Hello\")\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    loop = new_event_loop()\n"
"\n"
"    periodic = CronCallback(cron_function)\n"
"\n"
"    # call it each second after that\n"
"    periodic.start(spec=\"* * * * * *\")\n"
"\n"
"    loop.run_forever()"
msgstr ""
"import asyncio\n"
"import time\n"
"from aiomisc import new_event_loop, CronCallback\n"
"\n"
"\n"
"async def cron_function():\n"
"    print(\"Hello\")\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    loop = new_event_loop()\n"
"\n"
"    periodic = CronCallback(cron_function)\n"
"\n"
"    # Будем запускать это каждую секунду\n"
"    periodic.start(spec=\"* * * * * *\")\n"
"\n"
"    loop.run_forever()"
