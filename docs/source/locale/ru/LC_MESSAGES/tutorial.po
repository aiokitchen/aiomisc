# Translations template for aiomisc.
# Copyright (C) 2021
# This file is distributed under the same license as the aiomisc project.
# Dmitry Orlov <me@mosquito.su>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: aiomisc 16.1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-29 12:04+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../source/tutorial.rst:2
msgid "Tutorial"
msgstr "Учебник"

#: ../../source/tutorial.rst:5
msgid ""
"``aiomisc`` is a Python library that provides a set of utilities for "
"building asynchronous services. It allows you to split your program into "
"smaller, independent services that can run concurrently, improving the "
"overall performance and scalability of your application."
msgstr ""
"``aiomisc`` — это библиотека Python, которая предоставляет набор утилит "
"для создание асинхронных сервисов. Это позволяет вам разделить вашу "
"программу на небольшие независимые службы, которые могут работать "
"одновременно, улучшая общую производительность и масштабируемость вашего "
"приложения."

#: ../../source/tutorial.rst:10
msgid ""
"The main approach in this library is to split your program into "
"independent services that can work concurrently in asynchronous mode. The"
" library also provides a set of ready-to-use services with pre-written "
"start and stop logic."
msgstr ""
"Основным подходом в этой библиотеке является разделение вашей программы "
"на независимые сервисы, которые могут работать конкурентно в асинхронном "
"режиме. Библиотека также предоставляет набор готовых к использованию "
"сервисов с заранее написанной логикой запуска и остановки."

#: ../../source/tutorial.rst:14
msgid ""
"The vast majority of functions and classes are written in such a way that"
" they can be used in a program that was not originally designed according"
" to the principles outlined in this manual. This means that if you don't "
"plan to modify your code too much, but only use a few useful functions or"
" classes, then everything should work."
msgstr ""
"Подавляющее большинство функций и классов написаны таким образом, что их "
"можно использовать в программе, которая изначально не была разработана в "
"соответствии с принципами, изложенными в этом руководстве. Так что если "
"вы не планируете слишком сильно переписывать свой код, а хотите "
"использовать только несколько полезных для вас функций или классов, то "
"все должно работать."

#: ../../source/tutorial.rst:20
msgid ""
"Overall, aiomisc is a powerful tool for developers looking to build "
"efficient and scalable asynchronous services in Python."
msgstr ""
"В целом, aiomisc — это мощный инструмент для разработчиков, стремящихся "
"создавать эффективные и масштабируемые асинхронные сервисы на Python."

#: ../../source/tutorial.rst:24
msgid "Services"
msgstr "Сервисы"

#: ../../source/tutorial.rst:26
msgid ""
"If you want to run a tcp or web server, you will have to write something "
"like this:"
msgstr ""
"Если вы хотите запустить tcp или веб-сервер, вам придется написать что-то"
" вроде этого:"

#: ../../source/tutorial.rst:29
msgid ""
"import asyncio\n"
"\n"
"async def example_async_func():\n"
"    # do my async business logic\n"
"    await init_db()\n"
"    await init_cache()\n"
"    await start_http_server()\n"
"    await start_metrics_server()\n"
"\n"
"loop = asyncio.get_event_loop()\n"
"loop.run_until_complete(example_async_func())\n"
"# Continue running all background tasks\n"
"loop.run_forever()"
msgstr ""
"import asyncio\n"
"\n"
"async def example_async_func():\n"
"    # Делаем что-то асинхронное и очень важное\n"
"    await init_db()\n"
"    await init_cache()\n"
"    await start_http_server()\n"
"    await start_metrics_server()\n"
"\n"
"loop = asyncio.get_event_loop()\n"
"loop.run_until_complete(example_async_func())\n"
"# Продолжаем выполнение асинхронных задач\n"
"loop.run_forever()"

#: ../../source/tutorial.rst:45
msgid ""
"In order to start or stop an async programs, usually using function "
"``asyncio.run(example_async_func())`` which available since Python 3.7. "
"This function takes an instance of a coroutine and cancels all still "
"running tasks before returning a result. To continue executing the code "
"indefinitely, you can perform the following trick:"
msgstr ""
"Для того, чтобы запустить или остановить асинхронные программы, обычно "
"используется функция ``asyncio.run(example_async_func())``, которая "
"доступна начиная с Python 3.7. Функция принимает экземпляр сопрограммы и "
"отменяет через `cancel()` всем задачи перед тем как вернуть результат. "
"Чтобы продолжить выполнение кода вечно, вы можете применить следующий "
"трюк:"

#: ../../source/tutorial.rst:52
msgid ""
"import asyncio\n"
"\n"
"async def example_async_func():\n"
"    # do my async business logic\n"
"    await init_db()\n"
"    await init_cache()\n"
"    await start_http_server()\n"
"    await start_metrics_server()\n"
"\n"
"    # Make future which never be done\n"
"    # using instead loop.run_forever()\n"
"    await asyncio.Future()\n"
"\n"
"asyncio.run(example_async_func())"
msgstr ""
"import asyncio\n"
"\n"
"async def example_async_func():\n"
"    # Делаем что-то асинхронное и очень важное\n"
"    await init_db()\n"
"    await init_cache()\n"
"    await start_http_server()\n"
"    await start_metrics_server()\n"
"\n"
"    # Создаем future которая никогда не будет завершена\n"
"    # используется вместо loop.run_forever()\n"
"    await asyncio.Future()\n"
"\n"
"asyncio.run(example_async_func())"

#: ../../source/tutorial.rst:70
msgid ""
"When the user presses `Ctrl+C`, the program simply terminates, but if you"
" want to explicitly free up some resources, for example, close database "
"connections or rolling back incomplete transactions, then you have to do "
"something like this:"
msgstr ""
"Если пользователь нажимает `Ctrl+C`, программа просто завершается, но "
"если вы хотите явно освободить некоторые ресурсы, например, закрыть "
"соединения с базой данных или откатить незавершенные транзакции, то вам "
"нужно сделать что-то вроде этого:"

#: ../../source/tutorial.rst:75
msgid ""
"import asyncio\n"
"\n"
"async def example_async_func():\n"
"    try:\n"
"        # do my async business logic\n"
"        await init_db()\n"
"        await init_cache()\n"
"        await start_http_server()\n"
"        await start_metrics_server()\n"
"\n"
"        # Make future which never be done\n"
"        # using instead loop.run_forever()\n"
"        await asyncio.Future()\n"
"    except asyncio.CancelledError:\n"
"        # Do this block when SIGTERM has been received\n"
"        pass\n"
"    finally:\n"
"        # Do this block on exit\n"
"        ...\n"
"\n"
"asyncio.run(example_async_func())"
msgstr ""
"import asyncio\n"
"\n"
"async def example_async_func():\n"
"    try:\n"
"        # Делаем что-то асинхронное и очень важное\n"
"        await init_db()\n"
"        await init_cache()\n"
"        await start_http_server()\n"
"        await start_metrics_server()\n"
"\n"
"        # Создаем future которая никогда не будет завершена\n"
"        # используется вместо loop.run_forever()\n"
"        await asyncio.Future()\n"
"    except asyncio.CancelledError:\n"
"        # Зайдем в этот блок будет когда получим SIGTERM\n"
"        pass\n"
"    finally:\n"
"        # Зайдем сюда перед выходом\n"
"        ...\n"
"\n"
"asyncio.run(example_async_func())"

#: ../../source/tutorial.rst:100
msgid ""
"It is a good solution because it is implemented without any 3rd-party "
"libraries. When your program starts to grow, you will probably want to "
"optimize the startup time in a simple way, namely to do all "
"initialization competitively. At first glance it seems that this code "
"will solve the problem:"
msgstr ""
"Это хорошее решение, потому что оно реализовано без каких-либо сторонних "
"библиотек. Но когда ваша программа начнет расти, вы, вероятно, захотите "
"оптимизировать время запуска простым способом, а именно выполнить всю "
"инициализацию конкурентно. На первый взгляд кажется, что этот код решит "
"проблему:"

#: ../../source/tutorial.rst:106
msgid ""
"import asyncio\n"
"\n"
"async def example_async_func():\n"
"    try:\n"
"        # do my async business logic\n"
"        await asyncio.gather(\n"
"            init_db(),\n"
"            init_cache(),\n"
"            start_http_server(),\n"
"            start_metrics_server(),\n"
"        )\n"
"\n"
"        # Make future which never be done\n"
"        # using instead loop.run_forever()\n"
"        await asyncio.Future()\n"
"    except asyncio.CancelledError:\n"
"        # Do this block when SIGTERM has been received\n"
"        pass\n"
"    finally:\n"
"        # Do this block on exit\n"
"        ...\n"
"\n"
"asyncio.run(example_async_func())"
msgstr ""
"import asyncio\n"
"\n"
"async def example_async_func():\n"
"    try:\n"
"        # Делаем что-то асинхронное и очень важное\n"
"        await asyncio.gather(\n"
"            init_db(),\n"
"            init_cache(),\n"
"            start_http_server(),\n"
"            start_metrics_server(),\n"
"        )\n"
"\n"
"        # Создаем future которая никогда не будет завершена\n"
"        # используется вместо loop.run_forever()\n"
"        await asyncio.Future()\n"
"    except asyncio.CancelledError:\n"
"        # Зайдем в этот блок будет когда получим SIGTERM\n"
"        pass\n"
"    finally:\n"
"        # Зайдем сюда перед выходом\n"
"        ...\n"
"\n"
"asyncio.run(example_async_func())"

#: ../../source/tutorial.rst:132
msgid ""
"But if suddenly some part of the initialization does not go according to "
"plan, then you somehow have to figure out what exactly went wrong, so "
"with concurrent execution, the code will no longer be as simple as in "
"this example."
msgstr ""
"Но если вдруг какая-то часть инициализации пойдет не по плану, то вам "
"каким-то образом придется выяснить, что именно пошло не так. Поэтому при "
"конкурентном выполнении код уже не будет таким простым, как в этом "
"примере."

#: ../../source/tutorial.rst:136
msgid ""
"And in order to somehow organize the code, you should make a separate "
"function that will contain the ``try/except/finally`` block and contain "
"error handling."
msgstr ""
"И для того, чтобы как-то упорядочить код, вы должны сделать отдельную "
"функцию, которая будет содержать блок ``try/except/finally`` и содержать "
"обработку ошибок."

#: ../../source/tutorial.rst:141
msgid ""
"import asyncio\n"
"\n"
"async def init_db():\n"
"    try:\n"
"        # initialize connection\n"
"    finally:\n"
"        # close connection\n"
"        ...\n"
"\n"
"async def example_async_func():\n"
"    try:\n"
"        # do my async business logic\n"
"        await asyncio.gather(\n"
"            init_db(),\n"
"            init_cache(),\n"
"            start_http_server(),\n"
"            start_metrics_server(),\n"
"        )\n"
"\n"
"        # Make future which never be done\n"
"        # using instead loop.run_forever()\n"
"        await asyncio.Future()\n"
"    except asyncio.CancelledError:\n"
"        # Do this block when SIGTERM has been received\n"
"        # TODO: shutdown all things correctly\n"
"        pass\n"
"    finally:\n"
"        # Do this block on exit\n"
"        ...\n"
"\n"
"asyncio.run(example_async_func())"
msgstr ""
"import asyncio\n"
"\n"
"async def init_db():\n"
"    try:\n"
"        # инициализируем соединение\n"
"    finally:\n"
"        # закрываем соединение\n"
"        ...\n"
"\n"
"async def example_async_func():\n"
"    try:\n"
"        # Делаем что-то асинхронное и очень важное\n"
"        await asyncio.gather(\n"
"            init_db(),\n"
"            init_cache(),\n"
"            start_http_server(),\n"
"            start_metrics_server(),\n"
"        )\n"
"\n"
"        # Создаем future которая никогда не будет завершена\n"
"        # используется вместо loop.run_forever()\n"
"        await asyncio.Future()\n"
"    except asyncio.CancelledError:\n"
"        # Зайдем в этот блок будет когда получим SIGTERM\n"
"        # TODO: нужно как-то корректно все завершить\n"
"        pass\n"
"    finally:\n"
"        # Зайдем сюда перед выходом\n"
"        ...\n"
"\n"
"asyncio.run(example_async_func())"

#: ../../source/tutorial.rst:176
msgid ""
"And now if the user presses Ctrl+C, you need to describe the shutdown "
"logic again, but now in the ``except`` block."
msgstr ""
"И теперь, если пользователь нажимает Ctrl+C, вам нужно снова описать "
"логику завершения работы, но уже в блоке ``except``."

#: ../../source/tutorial.rst:179
msgid ""
"In order to describe the logic of starting and stopping in one place, as "
"well as testing in one single way, there is a ``Service`` abstraction."
msgstr ""
"Для того, чтобы описать логику запуска и остановки в одном месте, а также"
" тестирования одним-единственным способом, и существует абстракция "
"``Service``."

#: ../../source/tutorial.rst:182
msgid ""
"The service is an abstract base class with mandatory ``start()`` and "
"optional ``stop()`` methods."
msgstr ""
"Сервис представляет из себя абстрактный базовый класс, в котором нужно "
"реализовать метод ``start()`` и не обязательно метод ``stop()``"

#: ../../source/tutorial.rst:185
msgid ""
"The service can operate in two modes. The first is when the ``start()`` "
"method runs forever, then you do not need to implement a ``stop()``, but "
"you need to report that the initialization is successfully completed by "
"setting ``self.start_event.set()``."
msgstr ""
"Сервис может работать в двух режимах. Первый это когда метод старт "
"выполняется вечно, тогда не нужно реализовывать стоп, но нужно сообщить "
"что инициализация успешно закончена с помощью ``self.start_event.set()``."

#: ../../source/tutorial.rst:191
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"class InfinityService(aiomisc.Service):\n"
"    async def start(self):\n"
"        # Service is ready\n"
"        self.start_event.set()\n"
"\n"
"        while True:\n"
"            # do some stuff\n"
"            await asyncio.sleep(1)"
msgstr ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"class InfinityService(aiomisc.Service):\n"
"    async def start(self):\n"
"        # Сервис готов работать\n"
"        self.start_event.set()\n"
"\n"
"        while True:\n"
"            # Делаем что-то полезное\n"
"            await asyncio.sleep(1)"

#: ../../source/tutorial.rst:206
msgid ""
"In this case, stopping the service will consist in the completion of the "
"coroutine that was created by ``start()``."
msgstr ""
"В этом случае остановка сервиса будет заключаться в завершении "
"сопрограммы которую породила ``start()``"

#: ../../source/tutorial.rst:209
msgid ""
"The second method is an explicit description of the way to ``start()`` "
"and ``stop()``."
msgstr ""
"Второй способ это явное описание способа запуска и остановки реализовав "
"методы ``start()`` и ``stop()``"

#: ../../source/tutorial.rst:213
msgid ""
"import asyncio\n"
"import aiomisc\n"
"from typing import Any\n"
"\n"
"\n"
"class OrdinaryService(aiomisc.Service):\n"
"    async def start(self):\n"
"        # do some stuff\n"
"        ...\n"
"\n"
"    async def stop(self, exception: Exception = None) -> Any:\n"
"        # do some stuff\n"
"        ..."
msgstr ""
"import asyncio\n"
"import aiomisc\n"
"from typing import Any\n"
"\n"
"\n"
"class OrdinaryService(aiomisc.Service):\n"
"    async def start(self):\n"
"        # Делаем что-то полезное\n"
"        ...\n"
"\n"
"    async def stop(self, exception: Exception = None) -> Any:\n"
"        # Делаем что-то полезное\n"
"        ..."

#: ../../source/tutorial.rst:229
msgid "In this case, the service will be started and stopped once."
msgstr "В этом случае запуск и остановка сервиса будут выполнены однократно."

#: ../../source/tutorial.rst:233
msgid "Service configuration"
msgstr "Конфигурация сервисов"

#: ../../source/tutorial.rst:235
msgid ""
"The ``Service`` is a metaclass, it handles the special attributes of "
"classes inherited from it at on the their declaration stage."
msgstr ""
"Так как ``Service`` это метакласс, он может обрабатывать специальные "
"аттрибуты классов наследуемых от него на этапе объявления класса."

#: ../../source/tutorial.rst:238
msgid ""
"Here is a simple imperative example of how service initialization can be "
"extended through inheritance."
msgstr ""
"Вот простой императивный пример как инициализация сервиса может быть "
"расширена через наследование."

#: ../../source/tutorial.rst:241
msgid ""
"from typing import Any\n"
"import aiomisc\n"
"\n"
"class HelloService(aiomisc.Service):\n"
"    def __init__(self, name: str = \"world\", **kwargs: Any):\n"
"        super().__init__(**kwargs)\n"
"        self.name = name\n"
"\n"
"    async def start(self) -> Any:\n"
"        print(f\"Hello {self.name}\")\n"
"\n"
"with aiomisc.entrypoint(\n"
"    HelloService(),\n"
"    HelloService(name=\"Guido\")\n"
") as loop:\n"
"    pass\n"
"\n"
"# python hello.py\n"
"# <<< Hello world\n"
"# <<< Hello Guido"
msgstr ""
"from typing import Any\n"
"import aiomisc\n"
"\n"
"class HelloService(aiomisc.Service):\n"
"    def __init__(self, name: str = \"мир\", **kwargs: Any):\n"
"        super().__init__(**kwargs)\n"
"        self.name = name\n"
"\n"
"    async def start(self) -> Any:\n"
"        print(f\"Привет {self.name}\")\n"
"\n"
"with aiomisc.entrypoint(\n"
"    HelloService(),\n"
"    HelloService(name=\"Гвидо\")\n"
") as loop:\n"
"    pass\n"
"\n"
"# python hello.py\n"
"# <<< Привет мир\n"
"# <<< Привет Гвидо"

#: ../../source/tutorial.rst:264
msgid ""
"In fact, you can do nothing of this, since the Service metaclass sets all"
" the passed keyword parameters to self by default."
msgstr ""
"На самом деле, можно было ничего и не делать, так как метакласс установит"
" все переданные именованные параметры в self по умолчанию."

#: ../../source/tutorial.rst:267
msgid ""
"import aiomisc\n"
"\n"
"class HelloService(aiomisc.Service):\n"
"    name: str = \"world\"\n"
"\n"
"    async def start(self):\n"
"        print(f\"Hello {self.name}\")\n"
"\n"
"with aiomisc.entrypoint(\n"
"    HelloService(),\n"
"    HelloService(name=\"Guido\")\n"
") as loop:\n"
"    pass\n"
"\n"
"# python hello.py\n"
"# <<< Hello world\n"
"# <<< Hello Guido"
msgstr ""
"import aiomisc\n"
"\n"
"class HelloService(aiomisc.Service):\n"
"    name: str = \"мир\"\n"
"\n"
"    async def start(self):\n"
"        print(f\"Привет {self.name}\")\n"
"\n"
"with aiomisc.entrypoint(\n"
"    HelloService(),\n"
"    HelloService(name=\"Гвидо\")\n"
") as loop:\n"
"    pass\n"
"\n"
"# python hello.py\n"
"# <<< Привет мир\n"
"# <<< Привет Гвидо"

#: ../../source/tutorial.rst:287
msgid ""
"If a special class property ``__required__`` is declared, then the "
"service will required for the user to declare these named parameters."
msgstr ""
"Если-же объявлен специальный аттрибут ``__required__``, сервис будет "
"требовать чтобы он был передан явно при инициализации как именованный "
"параметр."

#: ../../source/tutorial.rst:290
msgid ""
"import aiomisc\n"
"\n"
"class HelloService(aiomisc.Service):\n"
"    __required__ = (\"name\", \"title\")\n"
"\n"
"    name: str\n"
"    title: str\n"
"\n"
"    async def start(self):\n"
"        await asyncio.sleep(0.1)\n"
"        print(f\"Hello {self.title} {self.name}\")\n"
"\n"
"with aiomisc.entrypoint(\n"
"    HelloService(name=\"Guido\", title=\"mr.\")\n"
") as loop:\n"
"    pass"
msgstr ""
"import aiomisc\n"
"\n"
"class HelloService(aiomisc.Service):\n"
"    __required__ = (\"name\", \"title\")\n"
"\n"
"    name: str\n"
"    title: str\n"
"\n"
"    async def start(self):\n"
"        await asyncio.sleep(0.1)\n"
"        print(f\"Привет {self.title} {self.name}\")\n"
"\n"
"with aiomisc.entrypoint(\n"
"    HelloService(name=\"Гвидо\", title=\"мистер\")\n"
") as loop:\n"
"    pass"

#: ../../source/tutorial.rst:309
msgid ""
"Also a very useful special class attribute is ``__async_required__``. It "
"is useful for writing base classes, in general. This contains the tuple "
"of method names that must be declared asynchronous explicitly (via "
"``async def``)."
msgstr ""
"Также очень полезный специальным атрибут класса это "
"``__async_required__``. В общем, это полезно для написания базовых "
"классов. Он содержит кортеж имен методов, которые должны быть явно "
"объявлены асинхронными (через ``async def``)."

#: ../../source/tutorial.rst:313
msgid ""
"import aiomisc\n"
"\n"
"class HelloService(aiomisc.Service):\n"
"    __required__ = (\"name\", \"title\")\n"
"    __async_required__ = (\"greeting\",)\n"
"\n"
"    name: str\n"
"    title: str\n"
"\n"
"    async def greeting(self) -> str:\n"
"        await asyncio.sleep(0.1)\n"
"        return f\"Hello {self.title} {self.name}\"\n"
"\n"
"    async def start(self):\n"
"        print(await self.greeting())\n"
"\n"
"class HelloEmojiService(HelloService):\n"
"    async def greeting(self) -> str:\n"
"        await asyncio.sleep(0.1)\n"
"        return f\"🙋 {self.title} {self.name}\"\n"
"\n"
"with aiomisc.entrypoint(\n"
"    HelloService(name=\"Guido\", title=\"mr.\"),\n"
"    HelloEmojiService(name=\"👨\", title=\"🎩\")\n"
") as loop:\n"
"    pass\n"
"\n"
"# Hello mr. Guido\n"
"# 🙋 🎩 👨"
msgstr ""
"import aiomisc\n"
"\n"
"class HelloService(aiomisc.Service):\n"
"    __required__ = (\"name\", \"title\")\n"
"    __async_required__ = (\"greeting\",)\n"
"\n"
"    name: str\n"
"    title: str\n"
"\n"
"    async def greeting(self) -> str:\n"
"        await asyncio.sleep(0.1)\n"
"        return f\"Привет {self.title} {self.name}\"\n"
"\n"
"    async def start(self):\n"
"        print(await self.greeting())\n"
"\n"
"class HelloEmojiService(HelloService):\n"
"    async def greeting(self) -> str:\n"
"        await asyncio.sleep(0.1)\n"
"        return f\"🙋 {self.title} {self.name}\"\n"
"\n"
"with aiomisc.entrypoint(\n"
"    HelloService(name=\"Гвидо\", title=\"мистер\"),\n"
"    HelloEmojiService(name=\"👨\", title=\"🎩\")\n"
") as loop:\n"
"    pass\n"
"\n"
"# Привет мистер Гвидо\n"
"# 🙋 🎩 👨"

#: ../../source/tutorial.rst:345
msgid ""
"If the inheritor declares these methods differently, there will be an "
"error at the class declaration stage."
msgstr ""
"Если наследник объявит эти методы по-другому, будет ошибка на этапе "
"объявления класса."

#: ../../source/tutorial.rst:348
msgid ""
"class BadHello(HelloService):\n"
"    def greeting(self) -> str:\n"
"        return f\"{self.title} {self.name}\"\n"
"\n"
"#Traceback (most recent call last):\n"
"#...\n"
"#TypeError: ('Following methods must be coroutine functions', "
"('BadHello.greeting',))"
msgstr ""

#: ../../source/tutorial.rst:360
msgid "dependency injection"
msgstr ""

#: ../../source/tutorial.rst:364
msgid ""
"In some cases, you need to execute some asynchronous code before the "
"service starts, for example, to pass a database connection to the service"
" instance. Or if you want to use one instance of some entity for several "
"services."
msgstr ""
"В некоторых случаях перед запуском службы необходимо выполнить некоторый "
"асинхронный код, например, чтобы передать соединение с базой данных "
"экземпляру сервиса. Или если вы хотите использовать один экземпляр "
"какой-то сущности для нескольких сервисов."

#: ../../source/tutorial.rst:368
msgid ""
"For such complex configurations, there is `aiomisc-dependency`_ plugin "
"which is distributed as a independent separate package."
msgstr ""
"Для таких сложных конфигураций существует плагин `aiomisc-dependency`_, "
"который распространяется как независимый отдельный пакет."

#: ../../source/tutorial.rst:371
msgid ""
"Look at the examples in the documentation, `aiomisc-dependency`_ are "
"transparently integrates with the ``entrypoint``."
msgstr ""
"Посмотрите на примеры в документации, `aiomisc-dependency`_ прозрачно "
"интегрируется с ``entrypoint``."

#: ../../source/tutorial.rst:375
msgid "``entrypoint``"
msgstr ""

#: ../../source/tutorial.rst:377
msgid ""
"So the service abstraction is declared, what's next? ``asyncio.run`` does"
" not know how to work with them, calling them manually has not become "
"easier, what can this library offer here?"
msgstr ""
"Итак сервисы описаны, что дальше? ``asyncio.run`` не умеет с ними "
"работать, вызывать их вручную не стало проще, что тут можно предложить?"

#: ../../source/tutorial.rst:381
msgid ""
"Probably the most magical, complex, and at the same time quite well-"
"tested code in the library is ``entrypoint``. Initially, the idea of "
"``entrypoint`` was to get rid of the routine: setting up logs, setting up"
" a thread pool, as well as starting and stopping services correctly."
msgstr ""
"Наверное самый магический, сложный, и в то-же время достаточно хорошо "
"протестированный код в библиотеке - это ``entrypoint``. Изначально идеей "
"``entrypoint`` было избавление от рутины: настройка логов, настройка пула"
" потоков, ну и запуск и корректная остановка сервисов."

#: ../../source/tutorial.rst:386
msgid "Lets check an example:"
msgstr "Давайте посмотрим на пример:"

#: ../../source/tutorial.rst:388
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"...\n"
"\n"
"with aiomisc.entrypoint(\n"
"    OrdinaryService(),\n"
"    InfinityService()\n"
") as loop:\n"
"    loop.run_forever()"
msgstr ""

#: ../../source/tutorial.rst:401
msgid ""
"In this example, we will launch the two services described above and "
"continue execution until the user interrupts them. Next, thanks to the "
"context manager, we correctly terminate all instances of services."
msgstr ""
"В этом примере мы запускаем два сервиса, описанных выше, и продолжаем "
"выполнение до тех пор пока пользователь его не прервёт. Далее, благодаря "
"контекстному менеджеру, мы корректно завершаем все экземпляры сервисов."

#: ../../source/tutorial.rst:407
msgid ""
"Entrypoint calls all the ``start()`` methods in all services "
"concurrently, and if at least one of them fails, then all services will "
"be stopped."
msgstr ""
"Entrypoint вызывает все методы ``start()`` во всех сервисах конкурентно, "
"и если хотя-бы один из них упадет, все остальные сервисы будут "
"остановлены."

#: ../../source/tutorial.rst:410
msgid ""
"As mentioned above I just wanted to remove a lot of routine, let's look "
"at the same example, just pass all the default parameters to the "
"``entrypoint`` explicitly."
msgstr ""
"Я упоминал, что я хотел убрать много рутины, давайте посмотрим на тот же "
"пример, только передадим явно все параметры по умолчанию в "
"``entrypoint``."

#: ../../source/tutorial.rst:414
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"\n"
"...\n"
"\n"
"with aiomisc.entrypoint(\n"
"    OrdinaryService(),\n"
"    InfinityService(),\n"
"    pool_size=4,\n"
"    log_level=\"info\",\n"
"    log_format=\"color\",\n"
"    log_buffering=True,\n"
"    log_buffer_size=1024,\n"
"    log_flush_interval=0.2,\n"
"    log_config=True,\n"
"    policy=asyncio.DefaultEventLoopPolicy(),\n"
"    debug=False\n"
") as loop:\n"
"    loop.run_forever()"
msgstr ""

#: ../../source/tutorial.rst:437
msgid ""
"Let's not describe what each parameter does. But in general, "
"``entrypoint`` has create an event-loop, a four threads pool, set it for "
"the current event-loop, has configure a colored logger with buffered "
"output, and launched two services."
msgstr ""
"Давайте не будем останавливаться на том, что делает каждый параметр. Но в"
" целом, ``entrypoint`` создала цикл событий, пул из четырех потоков, "
"настроила его для текущего цикла событий, настроила логгер с \"цветным\" "
"буферизованным выводом и запустила два сервиса."

#: ../../source/tutorial.rst:442
msgid ""
"You can also run the ``entrypoint`` without services, just configure "
"logging and so on.:"
msgstr ""
"Также вы можете запустить ``entrypoint`` без сервисов, просто "
"сконфигурировать логирование и прочее:"

#: ../../source/tutorial.rst:445
msgid ""
"import asyncio\n"
"import logging\n"
"import aiomisc\n"
"\n"
"\n"
"async def sleep_and_exit():\n"
"    logging.info(\"Started\")\n"
"    await asyncio.sleep(1)\n"
"    logging.info(\"Exiting\")\n"
"\n"
"\n"
"with aiomisc.entrypoint(log_level=\"info\") as loop:\n"
"    loop.run_until_complete(sleep_and_exit())"
msgstr ""

#: ../../source/tutorial.rst:461
msgid ""
"It is also worth paying attention to the ``aiomisc.run``, which is "
"similar by its purpose to ``asyncio.run`` while supporting the start and "
"stop of services and so on."
msgstr ""
"Еще стоит обратить внимание на ``aiomisc.run`` который похож по своему "
"назначению на ``asyncio.run`` при этом поддерживает запуск и остановку "
"сервисов и прочее."

#: ../../source/tutorial.rst:465
msgid ""
"import asyncio\n"
"import logging\n"
"import aiomisc\n"
"\n"
"\n"
"async def sleep_and_exit():\n"
"    logging.info(\"Started\")\n"
"    await asyncio.sleep(1)\n"
"    logging.info(\"Exiting\")\n"
"\n"
"\n"
"aiomisc.run(\n"
"    # the first argument\n"
"    # is a main coroutine\n"
"    sleep_and_exit(),\n"
"    # Other positional arguments\n"
"    # is service instances\n"
"    OrdinaryService(),\n"
"    InfinityService(),\n"
"    # keyword arguments will\n"
"    # be passed as well to the entrypoint\n"
"    log_level=\"info\"\n"
")"
msgstr ""
"import asyncio\n"
"import logging\n"
"import aiomisc\n"
"\n"
"\n"
"async def sleep_and_exit():\n"
"    logging.info(\"Started\")\n"
"    await asyncio.sleep(1)\n"
"    logging.info(\"Exiting\")\n"
"\n"
"\n"
"aiomisc.run(\n"
"    # первый аргумент\n"
"    # это основная короутина\n"
"    sleep_and_exit(),\n"
"    # Другие позиционные аргументы\n"
"    # это экземпляры сервисов\n"
"    OrdinaryService(),\n"
"    InfinityService(),\n"
"    # другие именованные аргументы\n"
"    # будут просто переданы в entrypoint\n"
"    log_level=\"info\"\n"
")"

#: ../../source/tutorial.rst:493
msgid ""
"As I mentioned above, the library contains lots of already realized "
"abstract services that you can use in your project by simply implement "
"several methods."
msgstr ""
"Как я и упоминал ранее библиотека содержит большое количество готовых "
"абстрактных сервисов, которые вы можете использовать в своем проекте, "
"просто реализовав несколько методов."

#: ../../source/tutorial.rst:497
msgid ""
"A full list of services and usage examples can be found on the on the "
":doc:`Services page </services>`."
msgstr ""
"Полный список сервисов и примеры их использования можно найти на странице"
" :doc:`Сервисы </services>`."

#: ../../source/tutorial.rst:501
msgid "Executing code in thread or process-pools"
msgstr "Выполнение кода в пуле потоков или процессов"

#: ../../source/tutorial.rst:505
msgid ""
"As explained in `working with threads`_ section in official python "
"documentation asyncio event loop starts thread pool."
msgstr ""
"Как объясняется в разделе `working with threads`_ в официальной "
"документации по Python, eventloop в asyncio запускает пул потоков."

#: ../../source/tutorial.rst:508
msgid ""
"This pool is needed in order to run, for example, name resolution and not"
" blocks the event loop while low-level ``gethostbyname`` call works."
msgstr ""
"Этот пул нужен для того, чтобы запустить, например, разрешение имен и не "
"блокировать eventloop, пока работает низкоуровневый вызов "
"`gethostbyname`."

#: ../../source/tutorial.rst:511
msgid ""
"The size of this thread pool should be configured at application startup,"
" otherwise you may run into all sorts of problems when this pool is too "
"large or too small."
msgstr ""
"Размер этого пула потоков должен быть настроен при запуске приложения, "
"иначе вы можете столкнуться со всевозможными проблемами, когда этот пул "
"слишком велик или слишком мал."

#: ../../source/tutorial.rst:515
msgid ""
"By default, the ``entrypoint`` creates a thread pool with size equal to "
"the number of CPU cores, but not less than 4 and no more than 32 threads."
" Of course you can specify as you need."
msgstr ""
"По умолчанию ``entrypoint`` создает пул потоков с размером, равным "
"количеству ядер процессора (минимум — 4, и максимум — 32). Конечно, вы "
"можете указать столько, сколько вам нужно."

#: ../../source/tutorial.rst:520
msgid "``@aiomisc.threaded`` decorator"
msgstr "Декоратор ``@aiomisc.threaded``"

#: ../../source/tutorial.rst:522
msgid ""
"The following recommendations for calling blocking functions in threads "
"given in `working with threads`_ section in official Python "
"documentation:"
msgstr ""
"В разделе `working with threads`_ официальной документации по python "
"даются следующие рекомендации по вызову блокирующих функций в потоках:"

#: ../../source/tutorial.rst:525
msgid ""
"import asyncio\n"
"\n"
"def blocking_io():\n"
"    # File operations (such as logging) can block the event loop.\n"
"    with open('/dev/urandom', 'rb') as f:\n"
"        return f.read(100)\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"    result = await loop.run_in_executor(None, blocking_io)\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"def blocking_io():\n"
"    # Файловые операции (такие как логирование) могут заблокировать event"
" loop.\n"
"    with open('/dev/urandom', 'rb') as f:\n"
"        return f.read(100)\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"    result = await loop.run_in_executor(None, blocking_io)\n"
"\n"
"asyncio.run(main())"

#: ../../source/tutorial.rst:540
msgid "This library provides a very simple way to do the same:"
msgstr "Эта библиотека содержит очень простой способ сделать тоже самое:"

#: ../../source/tutorial.rst:542
msgid ""
"import aiomisc\n"
"\n"
"@aiomisc.threaded\n"
"def blocking_io():\n"
"    with open('/dev/urandom', 'rb') as f:\n"
"        return f.read(100)\n"
"\n"
"async def main():\n"
"    result = await blocking_io()\n"
"\n"
"aiomisc.run(main())"
msgstr ""

#: ../../source/tutorial.rst:556
msgid ""
"As you can see in this example, it is enough to wrap the function with a "
"decorator ``aiomisc.threaded``, after that it will return an awaitable "
"object, but the code inside the function will be sent to the default "
"thread pool."
msgstr ""
"Как видно из этого примера, достаточно обернуть функцию декоратором "
"``aiomisc.threaded``, и она начнет возвращать awaitable объект, но код "
"внутри функции будет отправлен в пул потоков по умолчанию."

#: ../../source/tutorial.rst:562
msgid "``@aiomisc.threaded_separate`` decorator"
msgstr "Декоратор ``@aiomisc.threaded_separate``"

#: ../../source/tutorial.rst:564
msgid ""
"If the blocking function runs for a long time, or even indefinitely, in "
"other words, if the cost of creating a thread is insignificant compared "
"to the workload, then you can use the decorator "
"``aiomisc.threaded_separate``."
msgstr ""
"Если блокирующая функция работает долго, а то и бесконечно долго, иными "
"словами, если стоимость создания потока незначительна по сравнению с "
"сколько функция работает, то можно попробовать использовать декоратор "
"``aiomisc.threaded_separate``."

#: ../../source/tutorial.rst:568
msgid ""
"The decorator starts a new thread not associated with any pool. Тhe "
"thread will be terminated after the function execution is done."
msgstr ""
"Декоратор запускает новый поток, не связанный с каким-либо пулом потоков."
" Поток завершится после выхода из функции."

#: ../../source/tutorial.rst:571
msgid ""
"import hashlib\n"
"import aiomisc\n"
"\n"
"@aiomisc.threaded_separate\n"
"def another_one_useless_coin_miner():\n"
"    with open('/dev/urandom', 'rb') as f:\n"
"        hasher = hashlib.sha256()\n"
"        while True:\n"
"            hasher.update(f.read(1024))\n"
"            if hasher.hexdigest().startswith(\"0000\"):\n"
"                return hasher.hexdigest()\n"
"\n"
"async def main():\n"
"    print(\n"
"        \"the hash is\",\n"
"        await another_one_useless_coin_miner()\n"
"    )\n"
"\n"
"aiomisc.run(main())"
msgstr ""
"import hashlib\n"
"import aiomisc\n"
"\n"
"@aiomisc.threaded_separate\n"
"def another_one_useless_coin_miner():\n"
"    with open('/dev/urandom', 'rb') as f:\n"
"        hasher = hashlib.sha256()\n"
"        while True:\n"
"            hasher.update(f.read(1024))\n"
"            if hasher.hexdigest().startswith(\"0000\"):\n"
"                return hasher.hexdigest()\n"
"\n"
"async def main():\n"
"    print(\n"
"        \"Хэш получился вот такой:\",\n"
"        await another_one_useless_coin_miner()\n"
"    )\n"
"\n"
"aiomisc.run(main())"

#: ../../source/tutorial.rst:595
msgid ""
"This approach allows you not to occupy threads in the pool for a long "
"time, but at the same time does not limit the number of created threads "
"in any way."
msgstr ""
"Такой подход позволяет не занимать потоки в пуле надолго, но при этом "
"никак не ограничивает количество создаваемых потоков."

#: ../../source/tutorial.rst:599
msgid "More examples you can be found in :doc:`/threads`."
msgstr "Больше примеров можно найти на странице :doc:`/threads`"

#: ../../source/tutorial.rst:602
msgid "``@aiomisc.threaded_iterable`` decorator"
msgstr "Декоратор ``@aiomisc.threaded_iterable``"

#: ../../source/tutorial.rst:604
msgid ""
"If a generator needs to be executed in a thread, there are problems with "
"synchronization of the thread and the eventloop. This library provides a "
"custom decorator designed to turn a synchronous generator into an "
"asynchronous one."
msgstr ""
"Если генератор нужно выполнить в потоке, возникают проблемы с "
"синхронизацией потока и eventloop. Эта библиотека предоставляет "
"пользовательский декоратор, предназначенный для превращения синхронного "
"генератора в асинхронный."

#: ../../source/tutorial.rst:609
msgid ""
"This is very useful if, for example, a queue or database driver has "
"written synchronous, but you want to use it efficiently in asynchronous "
"code."
msgstr ""
"Это очень полезно, если, например, драйвер очереди или базы данных "
"синхронный, но вы хотите эффективно использовать его в асинхронном коде."

#: ../../source/tutorial.rst:612
msgid ""
"import aiomisc\n"
"\n"
"@aiomisc.threaded_iterable(max_size=8)\n"
"def urandom_reader():\n"
"    with open('/dev/urandom', \"rb\") as fp:\n"
"        while True:\n"
"            yield fp.read(8)\n"
"\n"
"async def main():\n"
"    counter = 0\n"
"    async for chunk in urandom_reader():\n"
"        print(chunk)\n"
"        counter += 1\n"
"        if counter > 16:\n"
"            break\n"
"\n"
"aiomisc.run(main())"
msgstr ""

#: ../../source/tutorial.rst:632
msgid ""
"Under the hood, this decorator returns a special object that has a queue,"
" and asynchronous iterator interface provides access to that queue."
msgstr ""
"Под капотом этот декоратор возвращает специальный объект с очередью, а "
"интерфейс асинхронного итератора обеспечивает доступ к этой очереди."

#: ../../source/tutorial.rst:635
msgid ""
"You should always specify the ``max_size`` parameter, which limits the "
"size of this queue and prevents threaded code from sending too much items"
" to asynchronous code, in case the asynchronous iteration in case the "
"asynchronous iteration slacking."
msgstr ""
"Всегда следует указывать параметр ``max_size``, который ограничивает "
"размер этой очереди и предотвращает отправку кода, который работает в "
"потоке, слишком большого количества элементов в асинхронный код, в случае"
" асинхронной итерации в случае, если асинхронный итератор забирает "
"элементы из этой очереди реже чем они поступают."

#: ../../source/tutorial.rst:641
msgid "Conclusion"
msgstr "Заключение"

#: ../../source/tutorial.rst:643
msgid ""
"On this we need to finish this tutorial, I hope everything was clear "
"here, and you learned a lot of useful things for yourself. A full "
"description of the remaining services is presented in the :doc:`/modules`"
" section, or in the source code. The authors have tried to make the "
"source code as clear and simple as possible, so feel free to explore it."
msgstr ""
"На этом нам нужно закончить этот учебник, надеюсь тут все было понятно, и "
"вы почерпнули для себя много полезного. Полное описание остальных "
"сервисов представлено в разделе :doc:`/modules`, или в исходном коде. Авторы "
"постарались сделать исходный код максимально понятным и простым, поэтому "
"не стесняйтесь исследовать его."
