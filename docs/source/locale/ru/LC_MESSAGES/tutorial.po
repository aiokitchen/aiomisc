# Translations template for aiomisc.
# Copyright (C) 2021
# This file is distributed under the same license as the aiomisc project.
# Dmitry Orlov <me@mosquito.su>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: aiomisc 16.1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-08-04 00:12+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../source/tutorial.rst:2
msgid "Tutorial"
msgstr "Учебник"

#: ../../source/tutorial.rst:5
msgid ""
"``aiomisc`` - is a one library collection of utilities that helps you "
"write asynchronous services."
msgstr ""
"``aiomisc`` - это набор утилит в одной библиотеке, которые помогают вам "
"писать асинхронные сервисы."

#: ../../source/tutorial.rst:8
msgid ""
"The main approach in this library is to split your program into "
"independent services that can work concurrently in asynchronous mode. The"
" library also provides a set of ready-to-use services with pre-written "
"start and stop logic."
msgstr ""
"Основным подходом в этой библиотеке является разделение вашей программы "
"на независимые сервисы, которые могут работать конкурентно в асинхронном "
"режиме. Библиотека также предоставляет набор готовых к использованию "
"сервисов с заранее написанной логикой запуска и остановки."

#: ../../source/tutorial.rst:12
msgid ""
"The vast majority of functions and classes are written in such a way that"
" they can be used in a program that was not originally designed according"
" to the principles outlined in this manual. This means that if you don't "
"plan to modify your code too much, but only use a few useful functions or"
" classes, then everything should work."
msgstr ""
"Подавляющее большинство функций и классов написаны таким образом, что их "
"можно использовать в программе, которая изначально не была разработана в "
"соответствии с принципами, изложенными в этом руководстве. Так что если "
"вы не планируете слишком сильно переписывать свой код, а хотите "
"использовать только несколько полезных для вас функций или классов, то "
"все должно работать."

#: ../../source/tutorial.rst:20
msgid "Services"
msgstr "Сервисы"

#: ../../source/tutorial.rst:22
msgid ""
"If you want to run a tcp or web server, you will have to write something "
"like this:"
msgstr ""
"Если вы хотите запустить tcp или веб-сервер, вам придется написать что-то"
" вроде этого:"

#: ../../source/tutorial.rst:41
msgid ""
"In order to start or stop an async programs, usually using function "
"``asyncio.run(example_async_func())`` which available since Python 3.7. "
"This function takes an instance of a coroutine and cancels all still "
"running tasks before returning a result. To continue executing the code "
"indefinitely, you can perform the following trick:"
msgstr ""
"Для того, чтобы запустить или остановить асинхронные программы, обычно "
"используется функция ``asyncio.run(example_async_func())``, которая "
"доступна начиная с Python 3.7. Функция принимает экземпляр сопрограммы и "
"отменяет через `cancel()` всем задачи перед тем как вернуть результат. "
"Чтобы продолжить выполнение кода вечно, вы можете применить следующий "
"трюк:"

#: ../../source/tutorial.rst:66
msgid ""
"When the user presses `Ctrl+C`, the program simply terminates, but if you"
" want to explicitly free up some resources, for example, close database "
"connections or rolling back incomplete transactions, then you have to do "
"something like this:"
msgstr ""
"Если пользователь нажимает `Ctrl+C`, программа просто завершается, но "
"если вы хотите явно освободить некоторые ресурсы, например, закрыть "
"соединения с базой данных или откатить незавершенные транзакции, то вам "
"нужно сделать что-то вроде этого:"

#: ../../source/tutorial.rst:96
msgid ""
"It is a good solution because it is implemented without any 3rd-party "
"libraries. When your program starts to grow, you will probably want to "
"optimize the startup time in a simple way, namely to do all "
"initialization competitively. At first glance it seems that this code "
"will solve the problem:"
msgstr ""
"Это хорошее решение, потому что оно реализовано без каких-либо сторонних "
"библиотек. Но когда ваша программа начнет расти, вы, вероятно, захотите "
"оптимизировать время запуска простым способом, а именно выполнить всю "
"инициализацию конкурентно. На первый взгляд кажется, что этот код решит "
"проблему:"

#: ../../source/tutorial.rst:128
msgid ""
"But if suddenly some part of the initialization does not go according to "
"plan, then you somehow have to figure out what exactly went wrong, so "
"with concurrent execution, the code will no longer be as simple as in "
"this example."
msgstr ""
"Но если вдруг какая-то часть инициализации пойдет не по плану, то вам "
"каким-то образом придется выяснить, что именно пошло не так. Поэтому при "
"конкурентном выполнении код уже не будет таким простым, как в этом "
"примере."

#: ../../source/tutorial.rst:132
msgid ""
"And in order to somehow organize the code, you should make a separate "
"function that will contain the ``try/except/finally`` block and contain "
"error handling."
msgstr ""
"И для того, чтобы как-то упорядочить код, вы должны сделать отдельную "
"функцию, которая будет содержать блок ``try/except/finally`` и содержать "
"обработку ошибок."

#: ../../source/tutorial.rst:172
msgid ""
"And now if the user presses Ctrl+C, you need to describe the shutdown "
"logic again, but now in the ``except`` block."
msgstr ""
"И теперь, если пользователь нажимает Ctrl+C, вам нужно снова описать "
"логику завершения работы, но уже в блоке ``except``."

#: ../../source/tutorial.rst:175
msgid ""
"In order to describe the logic of starting and stopping in one place, as "
"well as testing in one single way, there is a ``Service`` abstraction."
msgstr ""
"Для того, чтобы описать логику запуска и остановки в одном месте, а также"
" тестирования одним-единственным способом, и существует абстракция "
"``Service``."

#: ../../source/tutorial.rst:178
msgid ""
"The service is an abstract base class with mandatory ``start()`` and "
"optional ``stop()`` methods."
msgstr ""
"Сервис представляет из себя абстрактный базовый класс, в котором нужно "
"реализовать метод ``start()`` и не обязательно метод ``stop()``"

#: ../../source/tutorial.rst:181
msgid ""
"The service can operate in two modes. The first is when the ``start()`` "
"method runs forever, then you do not need to implement a ``stop()``, but "
"you need to report that the initialization is successfully completed by "
"setting ``self.start_event.set()``."
msgstr ""
"Сервис может работать в двух режимах. Первый это когда метод старт "
"выполняется вечно, тогда не нужно реализовывать стоп, но нужно сообщить "
"что инициализация успешно закончена с помощью ``self.start_event.set()``."

#: ../../source/tutorial.rst:202
msgid ""
"In this case, stopping the service will consist in the completion of the "
"coroutine that was created by ``start()``."
msgstr ""
"В этом случае остановка сервиса будет заключаться в завершении "
"сопрограммы которую породила ``start()``"

#: ../../source/tutorial.rst:205
msgid ""
"The second method is an explicit description of the way to ``start()`` "
"and ``stop()``."
msgstr ""
"Второй способ это явное описание способа запуска и остановки реализовав "
"методы ``start()`` и ``stop()``"

#: ../../source/tutorial.rst:225
msgid "In this case, the service will be started and stopped once."
msgstr "В этом случае запуск и остановка сервиса будут выполнены однократно."

#: ../../source/tutorial.rst:229
msgid "Service configuration"
msgstr "Конфигурация сервисов"

#: ../../source/tutorial.rst:231
msgid ""
"The ``Service`` is a metaclass, it handles the special attributes of "
"classes inherited from it at on the their declaration stage."
msgstr ""
"Так как ``Service`` это метакласс, он может обрабатывать специальные "
"аттрибуты классов наследуемых от него на этапе объявления класса."

#: ../../source/tutorial.rst:234
msgid ""
"Here is a simple imperative example of how service initialization can be "
"extended through inheritance."
msgstr ""
"Вот простой императивный пример как инициализация сервиса может быть "
"расширена через наследование."

#: ../../source/tutorial.rst:260
msgid ""
"In fact, you can do nothing of this, since the Service metaclass sets all"
" the passed keyword parameters to self by default."
msgstr ""
"На самом деле, можно было ничего и не делать, так как метакласс установит"
" все переданные именованные параметры в self по умолчанию."

#: ../../source/tutorial.rst:283
msgid ""
"If a special class property ``__required__`` is declared, then the "
"service will required for the user to declare these named parameters."
msgstr ""
"Если-же объявлен специальный аттрибут ``__required__``, сервис будет "
"требовать чтобы он был передан явно при инициализации как именованный "
"параметр."

#: ../../source/tutorial.rst:305
msgid ""
"Also a very useful special class attribute is ``__async_required__``. It "
"is useful for writing base classes, in general. This contains the tuple "
"of method names that must be declared asynchronous explicitly (via "
"``async def``)."
msgstr ""
"Также очень полезный специальным атрибут класса это "
"``__async_required__``. В общем, это полезно для написания базовых "
"классов. Он содержит кортеж имен методов, которые должны быть явно "
"объявлены асинхронными (через ``async def``)."

#: ../../source/tutorial.rst:341
msgid ""
"If the inheritor declares these methods differently, there will be an "
"error at the class declaration stage."
msgstr ""
"Если наследник объявит эти методы по-другому, будет ошибка на этапе "
"объявления класса."

#: ../../source/tutorial.rst:356
msgid "dependency injection"
msgstr ""

#: ../../source/tutorial.rst:360
msgid ""
"In some cases, you need to execute some asynchronous code before the "
"service starts, for example, to pass a database connection to the service"
" instance. Or if you want to use one instance of some entity for several "
"services."
msgstr ""
"В некоторых случаях перед запуском службы необходимо выполнить некоторый "
"асинхронный код, например, чтобы передать соединение с базой данных "
"экземпляру сервиса. Или если вы хотите использовать один экземпляр какой-то "
"сущности для нескольких сервисов."

#: ../../source/tutorial.rst:364
msgid ""
"For such complex configurations, there is `aiomisc-dependency`_ plugin "
"which is distributed as a independent separate package."
msgstr ""
"Для таких сложных конфигураций существует плагин `aiomisc-dependency`_, "
"который распространяется как независимый отдельный пакет."

#: ../../source/tutorial.rst:367
msgid ""
"Look at the examples in the documentation, `aiomisc-dependency`_ are "
"transparently integrates with the ``entrypoint``."
msgstr ""
"Посмотрите на примеры в документации, `aiomisc-dependency`_ прозрачно "
"интегрируется с ``entrypoint``."

#: ../../source/tutorial.rst:371
msgid "``entrypoint``"
msgstr ""

#: ../../source/tutorial.rst:373
msgid ""
"So the service abstraction is declared, what's next? ``asyncio.run`` does"
" not know how to work with them, calling them manually has not become "
"easier, what can this library offer here?"
msgstr ""
"Итак сервисы описаны, что дальше? ``asyncio.run`` не умеет с ними "
"работать, вызывать их вручную не стало проще, что тут можно предложить?"

#: ../../source/tutorial.rst:377
msgid ""
"Probably the most magical, complex, and at the same time quite well-"
"tested code in the library is ``entrypoint``. Initially, the idea of "
"``entrypoint`` was to get rid of the routine: setting up logs, setting up"
" a thread pool, as well as starting and stopping services correctly."
msgstr ""
"Наверное самый магический, сложный, и в то-же время достаточно хорошо "
"протестированный код в библиотеке - это ``entrypoint``. Изначально идеей "
"``entrypoint`` было избавление от рутины: настройка логов, настройка пула"
" потоков, ну и запуск и корректная остановка сервисов."

#: ../../source/tutorial.rst:382
msgid "Lets check an example:"
msgstr "Давайте посмотрим на пример:"

#: ../../source/tutorial.rst:397
msgid ""
"In this example, we will launch the two services described above and "
"continue execution until the user interrupts them. Next, thanks to the "
"context manager, we correctly terminate all instances of services."
msgstr ""
"В этом примере мы запускаем два сервиса, описанных выше, и продолжаем "
"выполнение до тех пор пока пользователь его не прервёт. Далее, благодаря "
"контекстному менеджеру, мы корректно завершаем все экземпляры сервисов."

#: ../../source/tutorial.rst:403
msgid ""
"Entrypoint calls all the ``start()`` methods in all services "
"concurrently, and if at least one of them fails, then all services will "
"be stopped."
msgstr ""
"Entrypoint вызывает все методы ``start()`` во всех сервисах конкурентно, "
"и если хотя-бы один из них упадет, все остальные сервисы будут остановлены."

#: ../../source/tutorial.rst:406
msgid ""
"As mentioned above I just wanted to remove a lot of routine, let's look "
"at the same example, just pass all the default parameters to the "
"``entrypoint`` explicitly."
msgstr ""
"Я упоминал, что я хотел убрать много рутины, давайте посмотрим на тот же "
"пример, только передадим явно все параметры по умолчанию в "
"``entrypoint``."

#: ../../source/tutorial.rst:433
msgid ""
"Let's not describe what each parameter does. But in general, "
"``entrypoint`` has create an event-loop, a four threads pool, set it for "
"the current event-loop, has configure a colored logger with buffered "
"output, and launched two services."
msgstr ""
"Давайте не будем останавливаться на том, что делает каждый параметр. Но в"
" целом, ``entrypoint`` создала цикл событий, пул из четырех потоков, "
"настроила его для текущего цикла событий, настроила логгер с \"цветным\" "
"буферизованным выводом и запустила два сервиса."

#: ../../source/tutorial.rst:438
msgid ""
"You can also run the ``entrypoint`` without services, just configure "
"logging and so on.:"
msgstr ""
"Также вы можете запустить ``entrypoint`` без сервисов, просто "
"сконфигурировать логирование и прочее:"

#: ../../source/tutorial.rst:457
msgid ""
"It is also worth paying attention to the ``aiomisc.run``, which is "
"similar by its purpose to ``asyncio.run`` while supporting the start and "
"stop of services and so on."
msgstr ""
"Еще стоит обратить внимание на ``aiomisc.run`` который похож по своему "
"назначению на ``asyncio.run`` при этом поддерживает запуск и остановку "
"сервисов и прочее."

#: ../../source/tutorial.rst:489
msgid ""
"As I mentioned above, the library contains lots of already realized "
"abstract services that you can use in your project by simply implement "
"several methods."
msgstr ""
"Как я и упоминал ранее библиотека содержит большое количество готовых "
"абстрактных сервисов, которые вы можете использовать в своем проекте, "
"просто реализовав несколько методов."

#: ../../source/tutorial.rst:493
msgid ""
"A full list of services and usage examples can be found on the on the "
":doc:`Services page </services>`."
msgstr ""
"Полный список сервисов и примеры их использования можно найти на странице"
" :doc:`Сервисы </services>`."

#: ../../source/tutorial.rst:497
msgid "Executing code in thread or process-pools"
msgstr "Выполнение кода в пуле потоков или процессов"

#: ../../source/tutorial.rst:501
msgid ""
"As explained in `working with threads`_ section in official python "
"documentation asyncio event loop starts thread pool."
msgstr ""
"Как объясняется в разделе `working with threads`_ в официальной "
"документации по Python, eventloop в asyncio запускает пул потоков."

#: ../../source/tutorial.rst:504
msgid ""
"This pool is needed in order to run, for example, name resolution and not"
" blocks the event loop while low-level ``gethostbyname`` call works."
msgstr ""
"Этот пул нужен для того, чтобы запустить, например, разрешение имен и не "
"блокировать eventloop, пока работает низкоуровневый вызов "
"`gethostbyname`."

#: ../../source/tutorial.rst:507
msgid ""
"The size of this thread pool should be configured at application startup,"
" otherwise you may run into all sorts of problems when this pool is too "
"large or too small."
msgstr ""
"Размер этого пула потоков должен быть настроен при запуске приложения, "
"иначе вы можете столкнуться со всевозможными проблемами, когда этот пул "
"слишком велик или слишком мал."

#: ../../source/tutorial.rst:511
msgid ""
"By default, the ``entrypoint`` creates a thread pool with size equal to "
"the number of CPU cores, but not less than 4 and no more than 32 threads."
" Of course you can specify as you need."
msgstr ""
"По умолчанию ``entrypoint`` создает пул потоков с размером, равным "
"количеству ядер процессора (минимум — 4, и максимум — 32). Конечно, вы "
"можете указать столько, сколько вам нужно."

#: ../../source/tutorial.rst:516
msgid "``@aiomisc.threaded`` decorator"
msgstr "Декоратор ``@aiomisc.threaded``"

#: ../../source/tutorial.rst:518
msgid ""
"The following recommendations for calling blocking functions in threads "
"given in `working with threads`_ section in official Python "
"documentation:"
msgstr ""
"В разделе `working with threads`_ официальной документации по python "
"даются следующие рекомендации по вызову блокирующих функций в потоках:"

#: ../../source/tutorial.rst:536
msgid "This library provides a very simple way to do the same:"
msgstr "Эта библиотека содержит очень простой способ сделать тоже самое:"

#: ../../source/tutorial.rst:552
msgid ""
"As you can see in this example, it is enough to wrap the function with a "
"decorator ``aiomisc.threaded``, after that it will return an awaitable "
"object, but the code inside the function will be sent to the default "
"thread pool."
msgstr ""
"Как видно из этого примера, достаточно обернуть функцию декоратором "
"``aiomisc.threaded``, и она начнет возвращать awaitable объект, но код "
"внутри функции будет отправлен в пул потоков по умолчанию."

#: ../../source/tutorial.rst:558
msgid "``@aiomisc.threaded_separate`` decorator"
msgstr "Декоратор ``@aiomisc.threaded_separate``"

#: ../../source/tutorial.rst:560
msgid ""
"If the blocking function runs for a long time, or even indefinitely, in "
"other words, if the cost of creating a thread is insignificant compared "
"to the workload, then you can use the decorator "
"``aiomisc.threaded_separate``."
msgstr ""
"Если блокирующая функция работает долго, а то и бесконечно долго, иными "
"словами, если стоимость создания потока незначительна по сравнению с "
"сколько функция работает, то можно попробовать использовать декоратор "
"``aiomisc.threaded_separate``."

#: ../../source/tutorial.rst:564
msgid ""
"The decorator starts a new thread not associated with any pool. Тhe "
"thread will be terminated after the function execution is done."
msgstr ""
"Декоратор запускает новый поток, не связанный с каким-либо пулом потоков."
" Поток завершится после выхода из функции."

#: ../../source/tutorial.rst:591
msgid ""
"This approach allows you not to occupy threads in the pool for a long "
"time, but at the same time does not limit the number of created threads "
"in any way."
msgstr ""
"Такой подход позволяет не занимать потоки в пуле надолго, но при этом "
"никак не ограничивает количество создаваемых потоков."

#: ../../source/tutorial.rst:595
msgid "More examples you can be found in :doc:`/threads`."
msgstr "Больше примеров можно найти на странице :doc:`/threads`"

#: ../../source/tutorial.rst:598
msgid "``@aiomisc.threaded_iterable`` decorator"
msgstr "Декоратор ``@aiomisc.threaded_iterable``"

#: ../../source/tutorial.rst:600
msgid ""
"If a generator needs to be executed in a thread, there are problems with "
"synchronization of the thread and the eventloop. This library provides a "
"custom decorator designed to turn a synchronous generator into an "
"asynchronous one."
msgstr ""
"Если генератор нужно выполнить в потоке, возникают проблемы с "
"синхронизацией потока и eventloop. Эта библиотека предоставляет "
"пользовательский декоратор, предназначенный для превращения синхронного "
"генератора в асинхронный."

#: ../../source/tutorial.rst:605
msgid ""
"This is very useful if, for example, a queue or database driver has "
"written synchronous, but you want to use it efficiently in asynchronous "
"code."
msgstr ""
"Это очень полезно, если, например, драйвер очереди или базы данных "
"синхронный, но вы хотите эффективно использовать его в асинхронном коде."

#: ../../source/tutorial.rst:628
msgid ""
"Under the hood, this decorator returns a special object that has a queue,"
" and asynchronous iterator interface provides access to that queue."
msgstr ""
"Под капотом этот декоратор возвращает специальный объект с очередью, а "
"интерфейс асинхронного итератора обеспечивает доступ к этой очереди."

#: ../../source/tutorial.rst:631
msgid ""
"You should always specify the ``max_size`` parameter, which limits the "
"size of this queue and prevents threaded code from sending too much items"
" to asynchronous code, in case the asynchronous iteration in case the "
"asynchronous iteration slacking."
msgstr ""
"Всегда следует указывать параметр ``max_size``, который ограничивает "
"размер этой очереди и предотвращает отправку кода, который работает в "
"потоке, слишком большого количества элементов в асинхронный код, в случае"
" асинхронной итерации в случае, если асинхронный итератор забирает "
"элементы из этой очереди реже чем они поступают."

