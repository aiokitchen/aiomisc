# Translations template for aiomisc.
# Copyright (C) 2021
# This file is distributed under the same license as the aiomisc project.
# Dmitry Orlov <me@mosquito.su>, 2022.
msgid ""
msgstr ""
"Project-Id-Version:  14\n"
"Report-Msgid-Bugs-To: me@mosquito.su\n"
"POT-Creation-Date: 2022-12-29 11:36+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dmitry Orlov <me@mosquito.su>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

# "Project-Id-Version: latest\n"
#: ../../source/worker_pool.rst:2
msgid "``WorkerPool``"
msgstr ""

#: ../../source/worker_pool.rst:4
msgid ""
"Python has the ``multiprocessing`` module with ``Pool`` class which "
"implements a similar worker pool. The IPC in this case uses a completely "
"synchronous communication method. This module reimplements the process-"
"based worker pool but IPC is completely asynchronous on the caller side, "
"meanwhile, workers in separate processes aren't asynchronous."
msgstr ""
"В Python есть модуль ``multiprocessing`` в котором реализован класс "
"``Pool``, это аналог этого модуля, за единственным исключением - IPC в "
"этом случае полностью синхронный. Этот модуль реализует Worker Pool на "
"основе процессов, но IPC, при этом, полностью асинхронный на вызывающей "
"стороне, при этом рабочие процессы не асинхронны."

#: ../../source/worker_pool.rst:11
msgid "Example"
msgstr "Пример"

#: ../../source/worker_pool.rst:13
msgid ""
"This would be useful when you want to process the data in a separate "
"process, and the input and output data are not very large. Otherwise, it "
"will work fine, of course, but you would have to spend time transmitting "
"the data over IPC."
msgstr ""
"Это полезно, когда вы хотите обрабатывать данные в отдельном процессе, "
"при этом входные и выходные данные не велики. В противном случае это, "
"конечно, будет работать нормально, но вам придется тратить время на "
"передачу данных по IPC."

#: ../../source/worker_pool.rst:18
msgid ""
"A good example is parallel image processing. Of course, you can transfer "
"bytes of images through the IPC of the working pool, but in general, case"
" passing the file name to the worker will be better. The exception will "
"be cases when the image payload is significantly smaller the 1KB for "
"example."
msgstr ""
"Хорошим примером является параллельная обработка изображений. Конечно, вы"
" можете передавать байты изображений через IPC рабочего пула, но в общем "
"случае передача имени файла будет лучше. Исключением будут случаи, когда "
"изображение очень маленькое меньше, к примеру 1 КБ."

#: ../../source/worker_pool.rst:23
msgid ""
"Let's write a program that accepts images in JPEG format and creates "
"thumbnails for this. In this case, you have a file with the original "
"image, and you should generate the output path for the 'thumbnail' "
"function."
msgstr ""
"Давайте напишем программу, которая принимает изображения в формате JPEG и"
" создает миниатюры. В этом случае у вас есть файл с исходным "
"изображением, и вы должны сгенерировать выходной путь для функции "
"«thumbnail»."

#: ../../source/worker_pool.rst:29
msgid ""
"You have to install the Pillow image processing library to run this "
"example."
msgstr ""
"Придется установить Pillow - библиотеку для работы с изображениями, чтобы"
" запустить этот код."

#: ../../source/worker_pool.rst:31
msgid "Installing pillow with pip:"
msgstr "Установка через pip:"

#: ../../source/worker_pool.rst:33
msgid "pip install Pillow"
msgstr ""

#: ../../source/worker_pool.rst:37
msgid ""
"import asyncio\n"
"import sys\n"
"from multiprocessing import cpu_count\n"
"from typing import Tuple\n"
"from pathlib import Path\n"
"from PIL import Image\n"
"from aiomisc import entrypoint, WorkerPool\n"
"\n"
"\n"
"def thumbnail(src_path: str, dest_path: str, box: Tuple[int, int]):\n"
"    img = Image.open(src_path)\n"
"    img.thumbnail(box)\n"
"    img.save(\n"
"        dest_path, \"JPEG\", quality=65,\n"
"        optimize=True,\n"
"        icc_profile=img.info.get('icc_profile'),\n"
"        exif=img.info.get('exif'),\n"
"    )\n"
"    return img.size\n"
"\n"
"\n"
"sizes = [\n"
"    (1024, 1024),\n"
"    (512, 512),\n"
"    (256, 256),\n"
"    (128, 128),\n"
"    (64, 64),\n"
"    (32, 32),\n"
"]\n"
"\n"
"\n"
"async def amain(path: Path):\n"
"    # Create directories\n"
"    for size in sizes:\n"
"        size_dir = \"x\".join(map(str, size))\n"
"        size_path = (path / 'thumbnails' / size_dir)\n"
"        size_path.mkdir(parents=True, exist_ok=True)\n"
"\n"
"    # Create and run WorkerPool\n"
"    async with WorkerPool(cpu_count()) as pool:\n"
"        tasks = []\n"
"        for image in path.iterdir():\n"
"            if not image.name.endswith(\".jpg\"):\n"
"                continue\n"
"\n"
"            if image.is_relative_to(path / 'thumbnails'):\n"
"                continue\n"
"\n"
"            for size in sizes:\n"
"                rel_path = image.relative_to(path).parent\n"
"                size_dir = \"x\".join(map(str, size))\n"
"                dest_path = (\n"
"                    path / rel_path /\n"
"                    'thumbnails' / size_dir /\n"
"                    image.name\n"
"                )\n"
"\n"
"                tasks.append(\n"
"                    pool.create_task(\n"
"                        thumbnail,\n"
"                        str(image),\n"
"                        str(dest_path),\n"
"                        size\n"
"                    )\n"
"                )\n"
"\n"
"        await asyncio.gather(*tasks)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    with entrypoint() as loop:\n"
"        image_dir = Path(sys.argv[1])\n"
"        loop.run_until_complete(amain(image_dir))"
msgstr ""
"import asyncio\n"
"import sys\n"
"from multiprocessing import cpu_count\n"
"from typing import Tuple\n"
"from pathlib import Path\n"
"from PIL import Image\n"
"from aiomisc import entrypoint, WorkerPool\n"
"\n"
"\n"
"def thumbnail(src_path: str, dest_path: str, box: Tuple[int, int]):\n"
"    img = Image.open(src_path)\n"
"    img.thumbnail(box)\n"
"    img.save(\n"
"        dest_path, \"JPEG\", quality=65,\n"
"        optimize=True,\n"
"        icc_profile=img.info.get('icc_profile'),\n"
"        exif=img.info.get('exif'),\n"
"    )\n"
"    return img.size\n"
"\n"
"\n"
"sizes = [\n"
"    (1024, 1024),\n"
"    (512, 512),\n"
"    (256, 256),\n"
"    (128, 128),\n"
"    (64, 64),\n"
"    (32, 32),\n"
"]\n"
"\n"
"\n"
"async def amain(path: Path):\n"
"    # Создаем директории\n"
"    for size in sizes:\n"
"        size_dir = \"x\".join(map(str, size))\n"
"        size_path = (path / 'thumbnails' / size_dir)\n"
"        size_path.mkdir(parents=True, exist_ok=True)\n"
"\n"
"    # Создаем и запускаем WorkerPool\n"
"    async with WorkerPool(cpu_count()) as pool:\n"
"        tasks = []\n"
"        for image in path.iterdir():\n"
"            if not image.name.endswith(\".jpg\"):\n"
"                continue\n"
"\n"
"            if image.is_relative_to(path / 'thumbnails'):\n"
"                continue\n"
"\n"
"            for size in sizes:\n"
"                rel_path = image.relative_to(path).parent\n"
"                size_dir = \"x\".join(map(str, size))\n"
"                dest_path = (\n"
"                    path / rel_path /\n"
"                    'thumbnails' / size_dir /\n"
"                    image.name\n"
"                )\n"
"\n"
"                tasks.append(\n"
"                    pool.create_task(\n"
"                        thumbnail,\n"
"                        str(image),\n"
"                        str(dest_path),\n"
"                        size\n"
"                    )\n"
"                )\n"
"\n"
"        await asyncio.gather(*tasks)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    with entrypoint() as loop:\n"
"        image_dir = Path(sys.argv[1])\n"
"        loop.run_until_complete(amain(image_dir))"

#: ../../source/worker_pool.rst:114
msgid ""
"This example takes the image directory as the first command-line argument"
" and creates directories for the thumbnails. After that, a ``WorkerPool``"
" is started with as many processes as the processor has cores."
msgstr ""
"В этом примере каталог изображений используется в качестве первого "
"аргумента командной строки и создает каталоги для эскизов. После этого "
"запускается ``WorkerPool`` с таким количеством процессов, сколько ядер у "
"процессора."

#: ../../source/worker_pool.rst:118
msgid ""
"The main process creates tasks for the workers, each task is a conversion"
" of one file to one size, after which all tasks fall into the "
"``WorkerPool`` instance."
msgstr ""
"Главный процесс создает задачи для рабочих, каждая задача это конвертация"
" одного изображения в один размер, и все эти задачи передаются в "
"``WorkerPool``"

#: ../../source/worker_pool.rst:122
msgid ""
"The ``WorkerPool`` processes the tasks concurrently, but only one job for"
" one a worker at the same time."
msgstr ""
"``WorkerPool`` обрабатывает задачи конкурентно, но не более одной задачи "
"на одного рабочего в один момент времени"
