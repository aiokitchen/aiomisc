# Translations template for aiomisc.
# Copyright (C) 2021
# This file is distributed under the same license as the aiomisc project.
# Dmitry Orlov <me@mosquito.su>, 2022.
msgid ""
msgstr ""
"Project-Id-Version:  14\n"
"Report-Msgid-Bugs-To: me@mosquito.su\n"
"POT-Creation-Date: 2022-12-29 11:36+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dmitry Orlov <me@mosquito.su>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../source/entrypoint.rst:2
msgid "entrypoint"
msgstr "Точка входа (`entrypoint`)"

#: ../../source/entrypoint.rst:4
msgid ""
"In the generic case, the entrypoint helper creates an event loop and "
"cancels already running coroutines on exit."
msgstr ""
"В общем случае точка входа это сущность помогающая создать event loop и "
"закрыть все еще запущенные корутины при выходе."

#: ../../source/entrypoint.rst:7
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"async def main():\n"
"    await asyncio.sleep(1)\n"
"\n"
"with aiomisc.entrypoint() as loop:\n"
"    loop.run_until_complete(main())"
msgstr ""

#: ../../source/entrypoint.rst:20
msgid "Complete example:"
msgstr "Пример целиком:"

#: ../../source/entrypoint.rst:22
msgid ""
"import asyncio\n"
"import aiomisc\n"
"import logging\n"
"\n"
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    logging.info(\"Hello there\")\n"
"\n"
"with aiomisc.entrypoint(\n"
"    pool_size=2,\n"
"    log_level='info',\n"
"    log_format='color',                         # default when \"rich\" "
"absent\n"
"    log_buffer_size=1024,                       # default\n"
"    log_flush_interval=0.2,                     # default\n"
"    log_config=True,                            # default\n"
"    policy=asyncio.DefaultEventLoopPolicy(),    # default\n"
"    debug=False,                                # default\n"
") as loop:\n"
"    loop.run_until_complete(main())"
msgstr ""
"import asyncio\n"
"import aiomisc\n"
"import logging\n"
"\n"
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    logging.info(\"Hello there\")\n"
"\n"
"with aiomisc.entrypoint(\n"
"    pool_size=2,\n"
"    log_level='info',\n"
"    log_format='color',                         # по умолчанию если \"rich\" "
"не установлен\n"
"    log_buffer_size=1024,                       # по умолчанию\n"
"    log_flush_interval=0.2,                     # по умолчанию\n"
"    log_config=True,                            # по умолчанию\n"
"    policy=asyncio.DefaultEventLoopPolicy(),    # по умолчанию\n"
"    debug=False,                                # по умолчанию\n"
") as loop:\n"
"    loop.run_until_complete(main())"

#: ../../source/entrypoint.rst:45
msgid "Running entrypoint from async code"
msgstr "Запуск точки входа (`entrypoint`) из асинхронного кода"

#: ../../source/entrypoint.rst:47
msgid ""
"import asyncio\n"
"import aiomisc\n"
"import logging\n"
"from aiomisc.service.periodic import PeriodicService\n"
"\n"
"log = logging.getLogger(__name__)\n"
"\n"
"class MyPeriodicService(PeriodicService):\n"
"    async def callback(self):\n"
"        log.info('Running periodic callback')\n"
"        # ...\n"
"\n"
"async def main():\n"
"    service = MyPeriodicService(interval=1, delay=0)  # once per minute\n"
"\n"
"    # returns an entrypoint instance because event-loop\n"
"    # already running and might be get via asyncio.get_event_loop()\n"
"    async with aiomisc.entrypoint(service) as ep:\n"
"        try:\n"
"            await asyncio.wait_for(ep.closing(), timeout=1)\n"
"        except asyncio.TimeoutError:\n"
"            pass\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import aiomisc\n"
"import logging\n"
"from aiomisc.service.periodic import PeriodicService\n"
"\n"
"log = logging.getLogger(__name__)\n"
"\n"
"class MyPeriodicService(PeriodicService):\n"
"    async def callback(self):\n"
"        log.info('Running periodic callback')\n"
"        # ...\n"
"\n"
"async def main():\n"
"    service = MyPeriodicService(interval=1, delay=0)  # once per minute\n"
"\n"
"    # вернет экземпляр entrypoint потому, что event-loop\n"
"    # уже запущен и может быть получен через asyncio.get_event_loop()\n"
"    async with aiomisc.entrypoint(service) as ep:\n"
"        try:\n"
"            await asyncio.wait_for(ep.closing(), timeout=1)\n"
"        except asyncio.TimeoutError:\n"
"            pass\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../source/entrypoint.rst:77
msgid "Configuration from environment"
msgstr "Конфигурация из переменных окружения"

#: ../../source/entrypoint.rst:79
msgid "Module support configuration from environment variables:"
msgstr "Модуль поддерживает конфигурацию из переменных окружения:"

#: ../../source/entrypoint.rst:81
msgid "`AIOMISC_LOG_LEVEL` - default logging level"
msgstr "`AIOMISC_LOG_LEVEL` - уровень логирования по умолчанию"

#: ../../source/entrypoint.rst:82
msgid "`AIOMISC_LOG_FORMAT` - default log format"
msgstr "`AIOMISC_LOG_FORMAT` - формат логирования по умолчанию"

#: ../../source/entrypoint.rst:83
msgid "`AIOMISC_LOG_CONFIG` - should logging be configured"
msgstr "`AIOMISC_LOG_CONFIG` - следует ли настраивать логирование"

#: ../../source/entrypoint.rst:84
msgid "`AIOMISC_LOG_FLUSH` - interval between logs flushing from buffer"
msgstr "`AIOMISC_LOG_FLUSH` - интервал сброса буфера логов logs"

#: ../../source/entrypoint.rst:85
msgid "`AIOMISC_LOG_BUFFERING` - should logging be buffered"
msgstr "`AIOMISC_LOG_BUFFERING` - следует ли включать буфферизацию логирования"

#: ../../source/entrypoint.rst:86
msgid "`AIOMISC_LOG_BUFFER_SIZE` - maximum log buffer size"
msgstr "`AIOMISC_LOG_BUFFER_SIZE` - максимальный размер буфера логов"

#: ../../source/entrypoint.rst:87
msgid "`AIOMISC_POOL_SIZE` - thread pool size"
msgstr "`AIOMISC_POOL_SIZE` - размер пула потоков"

#: ../../source/entrypoint.rst:91
msgid "``run()`` shortcut"
msgstr "Функция ``run()``"

#: ../../source/entrypoint.rst:93
msgid ""
"``aiomisc.run()`` - it's the short way to create and destroy "
"``aiomisc.entrypoint``. It's very similar to ``asyncio.run()`` but handle"
" ``Service``'s and other ``entrypoint``'s kwargs."
msgstr ""
"``aiomisc.run()`` - это простой способ создать и разрушить "
"``aiomisc.entrypoint``. Это очень похоже на ``asyncio.run()`` но "
"управляет сервисами ``aiomisc.Service`` и принимает прочие аргументы "
"entrypoint."

#: ../../source/entrypoint.rst:97
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_event_loop()\n"
"    now = loop.time()\n"
"    await asyncio.sleep(0.1)\n"
"    assert now < loop.time()\n"
"\n"
"\n"
"aiomisc.run(main())"
msgstr ""

#: ../../source/entrypoint.rst:113
msgid "Logging configuration"
msgstr "Конфигурация журналов"

#: ../../source/entrypoint.rst:115
msgid ""
"``entrypoint`` accepts a specific set of formats in which logs will be "
"written to stderr."
msgstr ""
"``entrypoint`` принимает определенный набор форматов, в которых журналы "
"будут записываться в stderr."

#: ../../source/entrypoint.rst:118
msgid "``stream`` - Python's default logging handler"
msgstr "``stream`` - стандартный python логгер"

#: ../../source/entrypoint.rst:119
msgid "``color`` - logging with `colorlog` module"
msgstr "``color`` - логирование через модуль ``colorlog``"

#: ../../source/entrypoint.rst:120
msgid "``json`` - json structure per each line"
msgstr "``json`` - json структура, одна на строчку"

#: ../../source/entrypoint.rst:121
msgid "``syslog`` - logging using stdlib `logging.handlers.SysLogHandler`"
msgstr "``syslog`` - ``logging.handlers.SysLogHandler`` из стандартной библиотеки"

#: ../../source/entrypoint.rst:122
msgid "``plain`` - just log messages, without date or level info"
msgstr ""
"``plain`` - просто сообщения, без даты или финормации об уровне "
"логирования"

#: ../../source/entrypoint.rst:123
msgid ""
"``journald`` - available only when `logging-journald` module has been "
"installed."
msgstr ""
"``journald`` - доступно только если ``logging-journald`` модуль "
"установлен."

#: ../../source/entrypoint.rst:125
msgid ""
"``rich``/``rich_tb` - available only when `rich` module has been "
"installed. ``rich_tb`` it's the same as ``rich`` but with fully expanded "
"tracebacks."
msgstr ""
"``rich``/``rich_tb`` - доступно только если ``rich`` модуль установлен. "
"``rich_tb`` тоже самое что и ``rich`` только с подробными трейсбэками."

#: ../../source/entrypoint.rst:128
msgid ""
"An ``entrypoint`` will call ``aiomisc.log.basic_config`` function "
"implicitly using passed ``log_level=`` and ``log_format=`` parameters. "
"Alternatively you can call ``aiomisc.log.basic_config`` function manually"
" passing it already created eventloop."
msgstr ""
"``entrypoint`` вызовет ``aiomisc.log.basic_config`` неявно используя "
"пеараметры ``log_level=`` и ``log_format=``. Как альтернатива, вы можете "
"вызвать ``aiomisc.log.basic_config`` вручную передав ей экземпляр "
"``eventloop``."

#: ../../source/entrypoint.rst:133
msgid ""
"However, you can configure logging earlier using "
"``aiomisc_log.basic_config``, but you will lose log buffering and "
"flushing in a separate thread. This function is what is actually called "
"during the logging configuration, the ``entrypoint`` passes a wrapper for"
" the handler there to flush it into the separate thread."
msgstr ""
"Однако вы можете настроить логирование раньше, используя "
"``aiomisc_log.basic_config``, но вы потеряете буферизацию и запись в "
"буфер отдельном потоке. Эта функция фактически вызывается во время "
"настройки ведения журнала, ``entrypoint`` передает обертку для logging "
"handler, чтобы он записывал в буфер в отдельном потоке."

#: ../../source/entrypoint.rst:139
msgid ""
"import logging\n"
"\n"
"from aiomisc_log import basic_config\n"
"\n"
"\n"
"basic_config(log_format=\"color\")\n"
"logging.info(\"Hello\")"
msgstr ""

#: ../../source/entrypoint.rst:149
msgid ""
"If you want to configure logging before the ``entrypoint`` is started, "
"for example after the arguments parsing, it is safe to configure it twice"
" (or more)."
msgstr ""
"Если вы хотите настроить ведение журнала перед запуском ``entrypoint``, "
"например, после разбора аргументов, это безопасно настроить его дважды "
"(или больше)."

#: ../../source/entrypoint.rst:153
msgid ""
"import logging\n"
"\n"
"import aiomisc\n"
"from aiomisc_log import basic_config\n"
"\n"
"\n"
"basic_config(log_format=\"color\")\n"
"logging.info(\"Hello from usual python\")\n"
"\n"
"\n"
"async def main():\n"
"    logging.info(\"Hello from async python\")\n"
"\n"
"\n"
"with aiomisc.entrypoint(log_format=\"color\") as loop:\n"
"    loop.run_until_complete(main())"
msgstr ""

#: ../../source/entrypoint.rst:173
msgid ""
"Sometimes you want to configure logging manually, the following example "
"demonstrates how to do this:"
msgstr ""
"Иногда вы хотите настроить ведение журнала самостоятельно, пример ниже "
"демонстрирует, как это сделать:"

#: ../../source/entrypoint.rst:176
#, python-format
msgid ""
"import os\n"
"import logging\n"
"from logging.handlers import RotatingFileHandler\n"
"from gzip import GzipFile\n"
"\n"
"import aiomisc\n"
"\n"
"\n"
"class GzipLogFile(GzipFile):\n"
"    def write(self, data) -> int:\n"
"        if isinstance(data, str):\n"
"            data = data.encode()\n"
"        return super().write(data)\n"
"\n"
"\n"
"class RotatingGzipFileHandler(RotatingFileHandler):\n"
"    \"\"\" Really added just for example you have to test it properly "
"\"\"\"\n"
"\n"
"    def shouldRollover(self, record):\n"
"        if not os.path.isfile(self.baseFilename):\n"
"            return False\n"
"        if self.stream is None:\n"
"            self.stream = self._open()\n"
"        return 0 < self.maxBytes < os.stat(self.baseFilename).st_size\n"
"\n"
"    def _open(self):\n"
"        return GzipLogFile(filename=self.baseFilename, mode=self.mode)\n"
"\n"
"\n"
"async def main():\n"
"    for _ in range(1_000):\n"
"        logging.info(\"Hello world\")\n"
"\n"
"\n"
"with aiomisc.entrypoint(log_config=False) as loop:\n"
"    gzip_handler = RotatingGzipFileHandler(\n"
"        \"app.log.gz\",\n"
"        # Maximum 100 files by 10 megabytes\n"
"        maxBytes=10 * 2 ** 20, backupCount=100\n"
"    )\n"
"    stream_handler = logging.StreamHandler()\n"
"\n"
"    formatter = logging.Formatter(\n"
"        \"[%(asctime)s] <%(levelname)s> \"\n"
"        \"%(filename)s:%(lineno)d (%(threadName)s): %(message)s\"\n"
"    )\n"
"\n"
"    gzip_handler.setFormatter(formatter)\n"
"    stream_handler.setFormatter(formatter)\n"
"\n"
"    logging.basicConfig(\n"
"        level=logging.INFO,\n"
"        # Wrapping all handlers in separate streams will not block the\n"
"        # event-loop even if gzip takes a long time to open the\n"
"        # file.\n"
"        handlers=map(\n"
"            aiomisc.log.wrap_logging_handler,\n"
"            (gzip_handler, stream_handler)\n"
"        )\n"
"    )\n"
"    loop.run_until_complete(main())"
msgstr ""
"import os\n"
"import logging\n"
"from logging.handlers import RotatingFileHandler\n"
"from gzip import GzipFile\n"
"\n"
"import aiomisc\n"
"\n"
"\n"
"class GzipLogFile(GzipFile):\n"
"    def write(self, data) -> int:\n"
"        if isinstance(data, str):\n"
"            data = data.encode()\n"
"        return super().write(data)\n"
"\n"
"\n"
"class RotatingGzipFileHandler(RotatingFileHandler):\n"
"    \"\"\" Really added just for example you have to test it properly "
"\"\"\"\n"
"\n"
"    def shouldRollover(self, record):\n"
"        if not os.path.isfile(self.baseFilename):\n"
"            return False\n"
"        if self.stream is None:\n"
"            self.stream = self._open()\n"
"        return 0 < self.maxBytes < os.stat(self.baseFilename).st_size\n"
"\n"
"    def _open(self):\n"
"        return GzipLogFile(filename=self.baseFilename, mode=self.mode)\n"
"\n"
"\n"
"async def main():\n"
"    for _ in range(1_000):\n"
"        logging.info(\"Hello world\")\n"
"\n"
"\n"
"with aiomisc.entrypoint(log_config=False) as loop:\n"
"    gzip_handler = RotatingGzipFileHandler(\n"
"        \"app.log.gz\",\n"
"        # Максимум 100 файлов по 10 мегабайт\n"
"        maxBytes=10 * 2 ** 20, backupCount=100\n"
"    )\n"
"    stream_handler = logging.StreamHandler()\n"
"\n"
"    formatter = logging.Formatter(\n"
"        \"[%(asctime)s] <%(levelname)s> \"\n"
"        \"%(filename)s:%(lineno)d (%(threadName)s): %(message)s\"\n"
"    )\n"
"\n"
"    gzip_handler.setFormatter(formatter)\n"
"    stream_handler.setFormatter(formatter)\n"
"\n"
"    logging.basicConfig(\n"
"        level=logging.INFO,\n"
"        # Обертывание всех обработчиков в отдельные потоки не заблокирует\n"
"        # event-loop даже если gzip занимает много времени, чтобы открыть\n"
"        # файл.\n"
"        handlers=map(\n"
"            aiomisc.log.wrap_logging_handler,\n"
"            (gzip_handler, stream_handler)\n"
"        )\n"
"    )\n"
"    loop.run_until_complete(main())"
