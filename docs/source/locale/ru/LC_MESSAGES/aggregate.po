# Translations template for aiomisc.
# Copyright (C) 2021
# This file is distributed under the same license as the aiomisc project.
# Dmitry Orlov <me@mosquito.su>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: aiomisc 12.1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-29 11:36+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Tzoiker tzoiker@gmail.com\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\@n"

#: ../../source/aggregate.rst:2
msgid "``@aiomisc.aggregate``"
msgstr ""

#: ../../source/aggregate.rst:4
msgid ""
"Parametric decorator that aggregates multiple (but no more than "
"``max_count`` defaulting to ``None``) single-argument executions (``res1 "
"= await func(arg1)``, ``res2 = await func(arg2)``, ...) of an "
"asynchronous function with variadic positional arguments (``async def "
"func(*args, pho=1, bo=2) -> Iterable``) into its single execution with "
"multiple positional arguments (``res1, res2, ... = await func(arg1, arg2,"
" ...)``) collected within a time window ``leeway_ms``. It offers a trade-"
"off between latency and throughput."
msgstr ""
"Параметрический декоратор, который агрегирует несколько (но не больше, "
"чем ``max_count``, по умолчанию ``None``) вызовов с одним параметром "
"(``res1 = await func(arg1)``, ``res2 = await func(arg2)``, ...) "
"асинхронной функции с переменными количеством позиционных параметров "
"(``async def func(*args, pho=1, bo=2) -> Iterable``) в единственный вызов"
" с несколькими параметрами (``res1, res2, ... = await func(arg1, arg2, "
"...)``), собранными в течение окна ``leeway_ms``. Он позволяет "
"пожертвовать задержкой ради увеличения пропускной спсобности."

#: ../../source/aggregate.rst:13
msgid ""
"If ``func`` raises an exception, then, all of the aggregated calls will "
"propagate the same exception. If one of the aggregated calls gets "
"canceled during the ``func`` execution, then, another will try to execute"
" the ``func``."
msgstr ""
"Если ``func`` бросает исключение, тогда все агрегированные вызовы бросят "
"то же самое исключение. Если один агрегированный вызов будет отменён во "
"время выполнения ``func``, тогда другой попробует выполнить ``func`` "
"вместо него."

#: ../../source/aggregate.rst:17
#, python-format
msgid ""
"This decorator may be useful if the ``func`` executes slow IO-tasks, is "
"frequently called, and using cache is not a good option. As a toy "
"example, assume that ``func`` fetches a record from the database by user "
"ID and it is called during each request to our service. If it takes 100 "
"ms to fetch a record and the load is 1000 RPS, then, with a 10% increase "
"of the delay (to 110 ms), it may decrease the number of requests to the "
"database by 10 times (to 100 QPS)."
msgstr ""
"Этот декоратор может быть полезен, если ``func`` выполняет медленные "
"IO-задачи, часто вызывается, а использование кеширования не "
"предпочтительно. В качестве примера, пусть ``func`` запрашивает запись из"
" БД по ID пользователя во время каждого запроса к нашему сервису. Если "
"запрос к БД занимает 100 мс, а нагрузка на сервис составляет 1000 RPS, то"
" с 10% увеличением задержки (до 110 ms) количество запросов к БД упадёт в"
" 10 раз (до 100 QPS) "

#: ../../source/aggregate.rst:27
msgid ""
"import asyncio\n"
"import math\n"
"from aiomisc import aggregate, entrypoint\n"
"\n"
"@aggregate(leeway_ms=10, max_count=2)\n"
"async def pow(*nums: float, power: float = 2.0):\n"
"    return [math.pow(num, power) for num in nums]\n"
"\n"
"async def main():\n"
"    await asyncio.gather(pow(1.0), pow(2.0))\n"
"\n"
"with entrypoint() as loop:\n"
"    loop.run_until_complete(main())"
msgstr ""

#: ../../source/aggregate.rst:44
msgid ""
"To employ a more low-level approach one can use `aggregate_async` "
"instead. In this case, the aggregating function accepts `Arg` parameters,"
" each containing `value` and `future` attributes. It is responsible for "
"setting the results of execution for all the futures (instead of "
"returning values)."
msgstr ""
"Для более низкоуровнего подхода можно воспользоваться декоратором "
"`aggregate_async`. В этом случае агрегирующая функция принимает в "
"качестве параметров переменные `Arg`, содержащие значение параметра "
"`value` и футуру `future`. Функция ответственна за выставление "
"результатов работы для всех футур (вместо обычного возврата результатов)."

#: ../../source/aggregate.rst:49
msgid ""
"import asyncio\n"
"import math\n"
"from aiomisc import aggregate_async, entrypoint\n"
"from aiomisc.aggregate import Arg\n"
"\n"
"\n"
"@aggregate_async(leeway_ms=10, max_count=2)\n"
"async def pow(*args: Arg, power: float = 2.0):\n"
"    for arg in args:\n"
"        arg.future.set_result(math.pow(arg.value, power))\n"
"\n"
"async def main():\n"
"    await asyncio.gather(pow(1), pow(2))\n"
"\n"
"with entrypoint() as loop:\n"
"    loop.run_until_complete(main())"
msgstr ""
